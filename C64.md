# Commodores 64

## Especificaciones

| Elemento | Descripción |
|:--------:|-------------|
| CPU | MOS Technology 6510 <br/> - PAL: 0.9852486 MHz <br/> - NTSC: 1.0227273 MHz |
| RAM | 64 KB |
| ROM | 20 KB dividido en 3 chips <br/> - 8 KB BASIC V2 (\$A000-\$BFFF) <br/> - 8 KB KERNAL (\$E000-\$FFFF) <br/> - 4 KB FONTS (\$D000-\$DFFF) |
| Gráficos | VIC-II (MOS 6567/6569) <br/> - Resolución: 320x200 <br/> - Colores: 16 <br/> - Sprites: 8 de 24x21 (2 colores) o 12x21 (4 colores) <br/> - Interrupciones del rasterizado |
| Sonido | SID (MOS 6581) <br/> - 3x Osciladores (8 octavas, 16-4000 Hz) <br/> - 4x Formas de onda (sierra, triángulo, cuadrada y ruido) <br/> - Filtros: paso-bajo (LPF), paso-alto (HPF) y paso-banda (BPF) <br/> - Envolvente (ADSR) <br/> - Modulación por anillo (Ring Modulation) |
| E/S | - 2x CIA 6526 (joystick, teclado, RS-232, GPIO) <br/> - Bus en serie IEEE 488 (disqueteras e impresoras) <br/> - Cintas de casete (datasette) <br/> - Cartuchos de ROM |
| Disco | Commodore 1541 (5¼ SS-SD, 170 KB) |

Para más información consulta la Wikipedia [inglesa](https://en.wikipedia.org/wiki/Commodore_64) o la [española](https://es.wikipedia.org/wiki/Commodore_64). También existe una [Wiki](https://www.c64-wiki.com/wiki/Main_Page) dedicada al C64 en inglés, donde poder consultar información sobre programar en la plataforma.

## Herramientas

- [VICE](https://vice-emu.sourceforge.io): Emulador del C64 para PC.
- [CCS64](http://www.ccs64.com): Emulador alternativo del C64 para PC.
- [CBM prg Studio](https://www.ajordison.co.uk): Entorno de desarrollo para C64 (BASIC y ensamblador).
- [CC65](https://cc65.github.io) ([GitHub](https://github.com/cc65/cc65)): Compilador de C para C64.
- [CheeseCutter](https://theyamo.kapsi.fi/ccutter/) ([GitHub](https://github.com/theyamo/CheeseCutter)): Editor de música SID para C64.
- [Multipaint](http://multipaint.kameli.net): Programa para dibujar usando los modos gráficos del C64.
- [CharPad](https://subchristsoftware.itch.io/charpad-free-edition): Editor de mapas para el C64.
- [SpritePad](https://csdb.dk/release/?id=132081): Editor de sprites para el C64.
- [SpriteMate](https://www.spritemate.com/): Editor de sprites online para el C64.

El emulador VICE tiene varias configuraciones para el teclado: modo simbólico y modo posicional. Para esta documentación asumimos que se está usando el modo simbólico.

## Lenguaje BASIC

### Hola mundo

Para empezar recurriremos al clásico Hola Mundo:

```BASIC
10 REM ESTO ES UN COMENTARIO
20 PRINT "HOLA MUNDO"
```

Todo programa en BASIC está compuesto por líneas con comandos. Cada línea empieza por un número identificador, de 0 a 63999, seguido de un comando del lenguaje. Las líneas tendrán un tamaño máximo de 80 caracteres. Opcionalmente podemos usar `:` para tener varios comandos dentro de una misma línea.

En el ejemplo tenemos dos líneas como parte del programa. En la primera tenemos un comentario de código usando el comando `REM`. En la segunda, con el comando `PRINT`, se envía un mensaje de texto a la pantalla. Para poder ejecutar el programa usaremos el comando `RUN`.

El C64 nos permite ver el código del programa cargado en memoria con `LIST`. 

$$\texttt{LIST}\ \textcolor{red}{[[} \mathit{primera} \textcolor{red}{]} \texttt{-} \textcolor{red}{[} \mathit{última} \textcolor{red}{]]}$$

| Parámetro | Descripción |
|:---------:|-------------|
| *primera* | Número de línea inicial del listado, por defecto es 0. |
| *última* | Número de línea final del listado, por defecto es 63999. |

Por ejemplo:

```BASIC
LIST 10     : REM Lista la línea 10 del programa.
LIST -10    : REM Lista hasta la línea 10 del programa.
LIST 10-    : REM Lista desde la línea 10 del programa.
LIST 10-100 : REM Lista desde la línea 10 hasta a la 100.
```

### Comentarios

Con el comando `REM` podemos comentar el código para documentarlo, pero estos comentarios ocupan espacio en la memoria de programa. Este comando ignora el uso de `:` para añadir varios comandos en la misma línea, ya que será ignorado todo lo que venga después de `REM` en la línea.

### Constantes

BASIC tiene tres tipos de datos: **números enteros**, **números flotantes** y **cadenas de texto**. Los tres los podemos expresar como valores literales de la siguiente manera:

- **Enteros:** Números de 16 bits con signo (2 Bytes). Desde `-32768` hasta `+32767`, usando [complemento a dos](https://es.wikipedia.org/wiki/Complemento_a_dos), usando la siguiente sintaxis:

$$\textcolor{red}{[}\texttt{+}\textcolor{red}{|}\texttt{-}\textcolor{red}{]} \mathit{d\acute{\imath}gitos}$$ 

- **Flotantes:** Números flotantes de 40 bits (5 Bytes). El exponente puede tener un valor desde `-39` hasta `+38`. Usan la siguiente sintaxis:

$$\textcolor{red}{[}\texttt{+}\textcolor{red}{|}\texttt{-}\textcolor{red}{]} \mathit{d\acute{\imath}gitos}\textcolor{red}{[}\texttt{.}\mathit{d\acute{\imath}gitos}\textcolor{red}{]} \textcolor{red}{[}\texttt{E}\textcolor{red}{[}\texttt{+}\textcolor{red}{|}\texttt{-}\textcolor{red}{]} \mathit{d\acute{\imath}gitos}\textcolor{red}{]}$$

- **Cadenas:** Cualquier texto que empieza y termina por dobles comillas (`"`).

Por ejemplo:

```BASIC
10 PRINT "CADENA DE TEXTO"     : REM CADENA DE TEXTO
20 PRINT "POSITIVO:"  1234     : REM POSITIVO: 1234     
30 PRINT "NEGATIVO:" -4321     : REM NEGATIVO:-4321
40 PRINT "FLOTANTE:" 6.543E-21 : REM FLOTANTE: 6.543E-21
```

El único carácter que no puede contener un literal de cadena de texto son las dobles comillas, sin embargo usando la función `CHR$(34)` podemos obtener una cadena de texto que contenga dobles comillas:
 
```BASIC
10 PRINT CHR$(34) "AMIGA" CHR$(34) : REM "AMIGA"
```

Por último, la constante **pi** está representada por la letra griega `π`, que se escribe con las teclas `MAYÚS`+`AvPág` en VICE y con `MAYÚS`+`SUPR` en CCS64.

```BASIC
10 PRINT π : REM 3.14159265
```

### Variables

Las variables nos permiten guardar valores con un nombre identificador, para poder recuperarlos y/o modificarlos más tarde. Un nombre identificador es una secuencia compuesta por letras (`A-Z`) y dígitos (`0-9`), que debe empezar siempre por una letra. Los tipos de variables que existen son:

- **Flotantes:** Almacenan números de coma flotante. Es el tipo por defecto de las variables, simplemente hay que definir un nombre identificador. Por ejemplo: `X`, `Y`, `Z`, etc.
- **Enteras:** Almacenan números enteros. Este tipo se asigna terminando el nombre identificador con el símbolo `%`. Por ejemplo: `I%`, `J%`, `K%`, etc.
- **Cadenas:** Almacenan cadenas de texto. Este tipo se asigna terminando el nombre identificador con el símbolo `$`. Por ejemplo: `N$`, `M$`, `S$`, etc.

Podemos asignar un valor a una variable con el operador `=`:

```BASIC
10 U  = 1.234
20 V% = 12345
30 W$ = "ABC"
```

El tamaño de un nombre identificador puede ser tan largo como una línea, pero el intérprete de BASIC sólo tiene en cuenta las dos primeras letras y su tipo. Es decir:

```BASIC
10 RAX  = 10
20 RAY  = 20
30 RAZ% = 30
40 PRINT RAX  : REM 20
50 PRINT RAZ% : REM 30
```

No podemos utilizar como nombres identificadores los que ya están asignados para los comandos de BASIC, así como sus abreviaciones, a las que llamaremos palabras reservadas del lenguaje.

### Operadores

El lenguaje dispone de diferentes operaciones para poder trabajar con los valores. A la hora de aplicar un operador, este tiene un nivel de prioridad que veremos al final de la sección. La primera categoría de operadores son los aritméticos:

| Símbolo | Descripción              |
|:-------:|--------------------------|
| `+`     | Suma / Prefijo positivo  |
| `-`     | Resta / Prefijo negativo |
| `*`     | Multiplicación           |
| `/`     | División                 |
| `↑`     | Exponenciación           |

El símbolo `↑` se escribe con la tecla `AvPág` en VICE y con `SUPR` en CCS64. Estas operaciones aritméticas se pueden utilizar con números enteros y reales. Por ejemplo:

```BASIC
10 A = 3 : B = 2
20 PRINT A + -B      : REM 1
30 PRINT A - B       : REM 1
40 PRINT A * B       : REM 6
50 PRINT A / B       : REM 1.5
60 PRINT A ↑ B       : REM 9
70 PRINT A + B / 2   : REM 4
80 PRINT (A + B) / 2 : REM 2.5
```

Nótese que con los paréntesis podemos alterar el orden de aplicación de los operadores, porque los paréntesis también son operadores en sí mismos.

El siguiente grupo de operadores son los de comparación:

| Símbolo | Descripción   |
|:-------:|---------------|
| `<`     | Menor         |
| `<=`    | Menor o igual |
| `=`     | Igual         |
| `>=`    | Mayor o igual |
| `>`     | Mayor         |
| `<>`    | Distinto      |

Podemos usar estos operadores con cualquier valor, para determinar qué orden tienen entre sí. Vemos que el símbolo `=` es usado por los operadores de igualdad y de asignación, pero sólo hay dos situaciones donde se usa la asignación:

```BASIC
10 A = 1
20 LET B = 2
30 PRINT A = B
```

Hemos dicho dos situaciones, pero en realidad es sólo una. En la línea `20` usamos el comando `LET`, que nos permite asignar a una variable (situada a la izquierda del `=`) un valor obtenido con una expresión (situada a la derecha del `=`). En la línea `10` en realidad estamos también usando el comando `LET`, pero podemos prescindir de la palabra clave `LET` para asignar un valor a una variable.

El siguiente grupo de operadores son los lógicos:

| Símbolo | Descripción   |
|:-------:|---------------|
| `NOT`   | Negación      |
| `AND`   | Conjunción    |
| `OR`    | Disyunción    |

Antes de continuar, necesitamos una pequeña explicación teórica:

> Los operadores de comparación, junto a los operadores lógicos, permiten crear **expresiones booleanas** que representan condiciones dentro de los programas, para poder tomar decisiones durante la ejecución. El resultado de una expresión booleana es un **valor booleano**, pero al no existir este tipo de dato en BASIC se utilizan los números enteros, usando `0` para indicar que la condición es **falsa** y cualquier otro valor entero para indicar que es **verdadera** (por ejemplo, cuando una comparación es verdadera se obtiene como resultado el `-1`).

Para entender mejor los operadores lógicos vamos a ver sus *tablas de verdad*:

| `A` | `B` | `NOT A` | `NOT B` | `A AND B` | `A OR B` |
|:---:|:---:|:-------:|:-------:|:---------:|:--------:|
|  V  |  V  |    F    |    F    |     V     |    V     |
|  F  |  V  |    V    |    F    |     F     |    V     |
|  V  |  F  |    F    |    V    |     F     |    V     |
|  F  |  F  |    V    |    V    |     F     |    F     |

Estos operadores lógicos funcionan a [nivel de bits](https://es.wikipedia.org/wiki/Operador_a_nivel_de_bits), es decir, se aplican a cada bit de los 16 que hay en un número entero de BASIC. Por lo tanto, si hacemos `2 OR 1` el resultado será `3`. Si intentamos usar un número real, con un operador lógico, el valor será transformado a un valor entero, para poder operar con él.

Finalmente, tenemos el grupo de operadores para manejar cadenas, que está compuesto únicamente por la concatenación, que utiliza el símbolo `+`. Por ejemplo:

```BASIC
10 A$ = "HOLA"
20 B$ = " MUNDO"
30 PRINT A$ + B$ : REM HOLA MUNDO
```

Por último, vamos a ver la prioridad de cada operador a la hora de ser aplicados en una expresión:
| Nivel | Operadores | Descripción |
|:-----:|:----------:|-------------|
| 1 | `↑` | Exponenciación |
| 2 | `+`<br/>`-` | Prefijos |
| 3 | `*`<br/>`/` | Multiplicación<br/>División |
| 4 | `+`<br/>`-` | Suma/Concatenación<br/>Resta |
| 5 | `<`<br/>`<=`<br/>`=`<br/>`>=`<br/>`>`<br/>`<>` | Comparación |
| 6 | `NOT` | Negación |
| 7 | `AND` | Conjunción |
| 8 | `OR` | Disyunción |

### Arrays

Los arrays son "tablas" de una o más dimensiones donde cada celda contiene un valor. En BASIC se utilizan los paréntesis, a la derecha de un nombre de variable con su tipo, para asignar o acceder a los valores que hay dentro. Por ejemplo:

```BASIC
10 A$(0) = "HOLA"
20 A$(1) = "MUNDO"
30 PRINT A$(0) " " A$(1) : REM HOLA MUNDO
```

Los arrays hay que definir su número de dimensiones y el tamaño de las mismas, ya que de no hacerlo se asignará por defecto un tamaño de 1 dimensión de 10 posiciones (índices del 0 al 9) la primera vez que utilicemos dicho array en el programa. Una vez dimensionado el array, no se podrá redimensionar su tamaño, porque nos saltaría un error de ejecución. Para definir el tamaño se utiliza el comando `DIM`:

$$\texttt{DIM}\ \mathit{variable} \texttt{(} \mathit{n_1} \textcolor{red}{[} \texttt{,}\ \mathit{n_2} \textcolor{red}{[} \texttt{,}\ \textcolor{red}{\dots]]} \texttt{)} \textcolor{red}{[} \texttt{,}\ \textcolor{red}{\dots]}$$

Con este comando podemos definir el tamaño de varios arrays, separado por comas. Un array puede tener hasta 255 dimensiones y el rango máximo disponible para cada índice es del 0 al 32767. Con $n_1$ definimos que la primera dimensión tiene tamaño $n_1$+1, es decir, que el índice de esta dimensión tiene como rango del 0 al $n_1$. Con $n_2$ definimos la segunda dimensión y así sucesivamente. Por ejemplo:

```BASIC
10 L(2) = 10  : REM TAM=10  L(0..9)     
20 DIM V(3)   : REM TAM=4   V(0..3)
30 DIM M(3,3) : REM TAM=4X4 M(0..3,0..3)
```

El interprete de BASIC trata como si fueran variables de programa distintas aquellas que son arrays, de las que no lo son, aunque compartan el mismo nombre, es decir, `A` y `A(0)` son variables diferentes dentro del programa. Por ejemplo:

```BASIC
10 A(0) = 1
20 A = 2
30 PRINT A(0) : REM 1
40 PRINT A    : REM 2
```

Podemos utilizar los arrays como parte de expresiones complejas junto a operadores y funciones del lenguaje.

### Usando la terminal

Definimos la terminal o consola como aquel dispositivo que utilizamos para interactuar con un computador. Normalmente está compuesto por una pantalla y un teclado. Cuando iniciamos el C64 veremos que nos muestra información sobre la máquina, el lenguaje y la memoria del sistema, para luego ver que hay un cuadrado parpadeando que nos indica la posición actual del cursor. Si pulsamos la tecla `A`, veremos que en efecto aparece en la pantalla la letra `A`. Esto es así porque al arrancar el C64 se ejecuta el programa que permite usar la máquina como una terminal de programación en BASIC. La gestión interna de la pantalla y del teclado a bajo nivel es compleja, por lo que será explicada más adelante en otra sección, sin embargo aquí veremos cómo BASIC nos permite usar la terminal.

En el C64 hay dos modos de fuente que usa la terminal de base. En el modo mayúsculas sólo tenemos las letras mayúsculas y en el modo minúsculas tendremos minúsculas al escribir y con la tecla `SHIFT` (`MAYUS` en VICE) podemos usar las letras mayúsculas. Para alternar entre los dos tipos se utiliza la combinación `SHIFT`+`C=` (`MAYUS`+`TAB` en VICE). En la siguiente imagen se ven las diferencias entre las dos fuentes:

<p align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/d/d8/Fonts-C64.png" alt="Fuentes del C64"></p>

Aunque ya lo hemos usado en varios de los ejemplos, para mostrar un mensaje por pantalla utilizamos el comando `PRINT`, que tiene la siguiente sintaxis:

$$\texttt{PRINT}\ \textcolor{red}{[} \mathit{expresión} \textcolor{red}{]\ [[} \texttt{;} \textcolor{red}{|} \texttt{,} \textcolor{red}{]}\ \mathit{expresión}\ \textcolor{red}{\dots]}$$ 

Una *expresión* es cualquier combinación de constantes, variables, operadores y funciones, que generan como resultado un valor que el comando usará para mostrarlo en la terminal. Por lo tanto, el resultado de una expresión será un número entero, un número flotante o una cadena de texto. Para separar las expresiones podemos usar `;`, sin que añada espacios en blanco, pero con `,` añadirá una tabulación entre un valor y el siguiente por pantalla. Por ejemplo:

```BASIC
10 PRINT "A";"B" : REM AB
20 PRINT "A","B" : REM A         B
```

El tabulado usa columnas de 10 caracteres de tamaño, por eso en la línea `20` la letra `B` se muestra en la columna 10, en lugar de la columna 1 como ocurre con la línea `10`. En algunos ejemplos previos, hemos visto que no era necesario usar `;` para separar algunas expresiones, sobre todo trabajando con cadenas, pero en caso de duda es mejor usar `;` y hacer más claro el código. Si usamos el `;` al final del comando `PRINT`, el cursor del terminal no realizará el salto de línea que habitualmente se hace al finalizar el comando. Otro comportamiento peculiar, que hay que tener en cuenta, es al mostrar un número se añadirá un espacio en blanco al inicio y al final del número:

```BASIC
10 PRINT "(";"ABC";")" : REM (ABC)
20 PRINT "(";12345;")" : REM ( 12345 )
30 PRINT "(";1.234;")" : REM ( 1.234 )
```

El comando `PRINT` sin nada se limita a dar un salto de línea con el cursor de la terminal.

Con el comando `INPUT` podemos introducir valores con el teclado, para obtener números y cadenas de texto. Para ello usamos la siguiente sintaxis:

$$\texttt{INPUT}\ \textcolor{red}{[} \mathit{cadena}\texttt{;} \textcolor{red}{]}\ \mathit{variable} \textcolor{red}{[} \texttt{,}\ \mathit{variable}\ \textcolor{red}{\dots]}$$

Con el parámetro opcional *cadena* podemos mostrar un mensaje inicial antes de introducir los valores. Tanto si usamos un mensaje inicial, como si no, lo siguiente que hace el comando es añadir a la terminal el carácter `?` y un espacio en blanco, para luego mostrar el cursor parpadeando, señal de que podemos introducir información. Los parámetros *variable* estarán separados por comas y dependiendo de su tipo habrá que meter un tipo de valor u otro por parte del usuario. Sólo al pulsar `RETURN` (`ENTER` en VICE) se procesa lo que hayamos escrito, para convertirlo a un valor que pueda ser almacenado en la variable. Si intentamos meter un valor de un tipo, en una variable de otro tipo, se producirá un error y se parará la ejecución. Por ejemplo:

```BASIC
10 INPUT A$,A%,A
20 PRINT "TEXTO:  ";A$
30 PRINT "ENTERO:";A%
40 PRINT "REAL:  ";A
```

El siguiente método de entrada es el comando `GET`:

$$\texttt{GET}\ \mathit{variable} \textcolor{red}{[} \texttt{,}\ \mathit{variable}\ \textcolor{red}{\dots]}$$

Este comando nos permite obtener caracteres del buffer de entrada que maneja la terminal, que tiene un tamaño de 10 caracteres (es decir, 10 bytes). El comando no bloquea la ejecución con su uso, por lo que si el buffer de entrada está vacío se le asignará el valor nulo por defecto a las variables (`""` para las cadenas y `0` para los números). Aunque podemos usar variables numéricas, es mejor usar variables de cadena de texto, para ir obteniendo el primer carácter del buffer de entrada, ya que con las numéricas recibiremos un error si pulsamos cualquier tecla que no sea un dígito o un carácter con el que se pueda escribir un número. Con este comando podremos hacer más dinámico el uso del teclado desde BASIC.

Por último, vamos a cubrir las funciones relacionadas con la entrada y salida de la terminal. La función `POS` nos devuelve la columna actual del cursor (desde `0` hasta `79`):

$$\texttt{POS(} \mathit{basura} \texttt{)}$$

Una limitación que tiene el interprete de BASIC es que no se puede definir en el lenguaje funciones sin parámetros, por ello `POS` tiene el parámetro *basura* que da igual el valor que le pasemos, porque no se va a utilizar. Por motivos de eficiencia, relacionados con la implementación del interprete, lo más óptimo es pasarle el literal pi (`π`).

Las funciones `SPC` y `TAB` las podremos usar con el comando `PRINT`. La primera añade espacios en blanco y la segunda define el ancho de columna para tabular:

$$\texttt{SPC(} \mathit{número} \texttt{)}$$

$$\texttt{TAB(} \mathit{número} \texttt{)}$$

Con el parámetro *número* indicamos el número de espacios que queremos añadir en `SPC` y el ancho de columna en `TAB`. Este número ha de ser un entero del `0` al `255`, de lo contrario se lanzará un error de ejecución. Hay una diferencia importante entre usar `TAB` y `,` dentro de `PRINT`. Si el valor previo excede el ancho de columna, la función `TAB` no añadirá más espacios, pero con `,` moverá el siguiente valor a la siguiente columna de tabulación.

### Sentencias de control

Después de ver diferentes aspectos básicos del lenguaje, vamos a explicar cómo controlar la ejecución del programa. Lo primero que debemos aprender es la sentencia condicional:

$$\texttt{IF}\ \mathit{condición}\ \texttt{THEN}\ \mathit{comando}\ \textcolor{red}{[} \texttt{:}\ \mathit{comando}\ \textcolor{red}{\dots]}$$

El comando `IF` nos permite ejecutar una serie de comandos si la *condición* es cierta. Las condiciones son expresiones booleanas, que vimos antes en la sección de los operadores. Por ejemplo:

```BASIC
10 INPUT "DAME UN NUMERO";N
20 IF N=0 THEN PRINT "CERO"
30 IF N>0 THEN PRINT "POSITIVO"
40 IF N<0 THEN PRINT "NEGATIVO"
```

Ahora que podemos tomar decisiones, vamos a aprender las sentencias de salto. La primera de ellas es el salto incondicional con `GOTO`:

$$\texttt{GOTO}\ \mathit{l\acute{\imath}nea}$$

Con este comando podemos enviar la ejecución actual a otra línea del programa. Luego tenemos la llamada a una subrutina con `GOSUB`

$$\texttt{GOSUB}\ \mathit{l\acute{\imath}nea}$$

Es similar a la anterior, pero la diferencia es que cuando encuentre una línea con el comando `RETURN`, volverá la posición de la ejecución a la línea del `GOSUB` que ha invocado la subrutina. Por ejemplo:

```BASIC
10 GOSUB 30
20 GOTO 10
30 PRINT "PULSA STOP/ESCAPE"
40 RETURN
```

El ejemplo llama primero con `GOSUB` a una subrutina ubicada en la línea `30`. La subrutina nos muestra un mensaje por pantalla y vuelve al punto de ejecución anterior con `RETURN`. Después con `GOTO` se realiza un bucle infinito. Pulsando la tecla `RUN/STOP` (`ESCAPE` en VICE) paramos la ejecución del interprete de BASIC y por ello logramos salir del bucle a lo bruto.

Ahora que conocemos los comandos de salto, vamos a ver una variante del comando `IF`:

$$\texttt{IF}\ \mathit{condición}\ \textcolor{red}{\{}\texttt{THEN}\textcolor{red}{|}\texttt{GOSUB}\textcolor{red}{|}\texttt{GOTO}\textcolor{red}{\}}\ \mathit{l\acute{\imath}nea}$$

Con este comando aplicaremos un salto si se cumple la condición, con `THEN` y `GOTO` será un salto directo, pero con `GOSUB` será un salto de subrutina. Por ejemplo:

```BASIC
10 PRINT "PULSA UNA TECLA"
20 GET K$
30 IF K$="" THEN 20
40 PRINT "PULSASTE: ";K$
50 IF K$<>CHR$(13) THEN 20
```

Este ejemplo ya tenemos bucles condicionales. En la línea `30` si no se ha capturado nada con `GET` volvemos a repetir el comando. Después de pulsar y capturar una tecla pulsada, mostramos cuál ha sido y en la línea `50` volveremos a dar la vuelta si no se ha pulsado la tecla `RETURN` (`ENTER` en VICE).

..

$$\texttt{FOR}\ \mathit{variable}\texttt{=}\mathit{inicio}\ \texttt{TO}\ \mathit{final}\ \textcolor{red}{[} \texttt{STEP}\ \mathit{incremento} \textcolor{red}{]}$$

$$\texttt{NEXT}\ \textcolor{red}{[} \mathit{variable} \textcolor{red}{[} \texttt{,}\ \mathit{variable}\ \textcolor{red}{\dots]]}$$

$$\texttt{ON}\ \mathit{expresión}\ \textcolor{red}{\{}\texttt{GOSUB}\textcolor{red}{|}\texttt{GOTO}\textcolor{red}{\}}\ \mathit{l\acute{\imath}nea} \textcolor{red}{[} \texttt{,}\ \mathit{l\acute{\imath}nea}\ \textcolor{red}{\dots]}$$

$$\textcolor{red}{[}\texttt{LET}\textcolor{red}{]}\ \mathit{variable}\texttt{=}\mathit{expresión}$$

..

### El reloj del sistema

..

$$\texttt{TIME}$$

$$\texttt{TIME\$}$$

### Funciones numéricas

..

$$\mathit{nombre}\texttt{(}\mathit{expresión}\texttt{)}$$

..

$$\texttt{DEF}\ \texttt{FN}\ \mathit{nombre}\texttt{(}\mathit{parámetro}\texttt{)} \texttt{=} \mathit{expresión}$$

$$\texttt{FN}\ \mathit{nombre}\texttt{(}\mathit{expresión}\texttt{)}$$

```
ABS(<numeric-expression>)
ATN(<numeric-expression>)
COS(<numeric-expression>)
EXP(<Number>)
INT(<Numeric>)
LOG(<Numeric>)
RND(<Number>)
SGN(<Numeric>)
SIN(<numeric-expression>)
SQR(<Numeric>)
TAN(<numeric-expression>)
```

### Funciones de cadenas

..

```
ASC(<String>)
CHR$(<numeric-expression>)
LEFT$(<string>,<integer number>)
LEN(<String>)
MID$(<string>, <intn1 - startchar>[, <intn2>])
RIGHT$(<string>,<integer number>)
STR$(<numerical>)
VAL(<String>)
```

### Manejo de datos

..

```
DATA <constant> [,<constant>]...
READ <variable> [,<variable>]...
RESTORE
```

### Gestión de ficheros

..

```
OPEN <logical filenumber> [,<device number> [,<secondary number> [,"<filename>[,<type>[,<mode>]]" ] ] ]
CLOSE <logical file number>
CMD <logical filenumber>[, [<expresson>] [ [ ";" ¦ "," ]<expression>...]]
PRINT# <logic file number>,<variable>[, (<--alternative ;)<variable>...]
INPUT# <logic file number>,<variable>[,<variable>...]
GET# <logic file number>,<variable>[,<variable>...]
STATUS
```

### Gestión del sistema

..

```
FRE(<dummy argument>)
PEEK(<Memory address>)
POKE <Memory address>,<number>
WAIT <Memoryadress>,<and-mask>[,<flip-mask>]
SYS <memory adress>
USR(<Number>)
```

### Control del interprete

..

```
RUN [<line number>]
STOP
CONT
END
NEW
CLR

LOAD ["<filename>" [,<device number> [,<secondary number>]]]
SAVE ["<filename>"] [,<device number>] [,<secondary number>]
VERIFY ["<filename>"] [,<device number>]
```

### Códigos de escape

Cuando usamos el teclado del C64 este genera códigos PETSCII que podemos utilizar con los comandos de entrada y salida que hemos visto. Algunos de estos códigos de escape permiten operaciones especiales con el comando `PRINT`, los podemos incorporar con la función `CHR$` o con el modo de edición especial de las comillas dobles.

El modo de edición de las comillas dobles se activa cuando pulsamos `"` y se desactiva cuando volvemos a pulsar `"` por segunda vez. Este modo está disponible mientras estemos escribiendo un programa en BASIC con el C64. Con este modo podemos introducir, como caracteres visibles, los códigos de escape en lugar de que se ejecute su subrutina. Por ejemplo, si pulsamos la tecla `⇑ CRSR ⇓`, esta envía el código 17, que es capturado y como consecuencia mueve el cursor una posición hacia abajo. Si pulsamos esa tecla, estando en el modo de edición especial, podemos observar que nos pinta en pantalla un `Q` con los colores invertidos, que es la representación visual de dicho código de escape. Si pasamos a `PRINT` una cadena que contenga dicho carácter, veremos que el mensaje se parte por dos, con una parte en una línea y la otra en la siguiente.

Desde el entorno de desarrollo *CBM prg Studio* podemos introducir estos códigos de escape mediante ciertas marcas especiales dentro de las cadenas de texto, ya que estas tienen que ser traducidas de ASCII a PETSCII. Estas marcas van entre llaves `{}`, poniendo dentro el nombre que identifica al código de escape. Por ejemplo, para el código 17 que hemos visto antes, tendremos la marca `{down}`. Podemos ver cuáles están disponibles desde `Tools`+`Screen Code Builder...` o pulsando `F4`, nos aparecerá una ventana llamada `Screen Codes` donde está la pestaña `Key Codes`.

El primer grupo de código de escapes nos permiten cambiar la configuración de la terminal del C64:

| PETSCII | C64 | VICE | CBM prg Studio | Descripción |
|:-------:|:---:|:----:|:--------------:|-------------|
| 8   | `CTRL`+`H` | `CTRL`+`H` | `{ct h}` | Desactiva el cambio de modo de fuente. |
| 9   | `CTRL`+`I` | `CTRL`+`I` | `{ct i}` | Activa el cambio de modo de fuente. |
| 14  | `CTRL`+`N` | `CTRL`+`N` | `{ct n}` | Activa el modo de fuente minúsculas. |
| 18  | `CTRL`+`9` | `CTRL`+`9` | `{reverse on}` | Color invertido activado. |
| 146 | `CTRL`+`0` | `CTRL`+`0` | `{reverse off}` | Color invertido desactivado. |
| 142 | | | `{142}`  | Activa el modo de fuente mayúsculas. |

El segundo grupo nos permite, mientras estemos usando el comando `PRINT`, poder modificar la terminal y la posición actual del cursor:

| PETSCII | C64 | VICE | CBM prg Studio | Descripción |
|:-------:|:---:|:----:|:--------------:|-------------|
| 147 | `SHIFT`+`CLR/HOME` | `MAYUS`+`INICIO` | `{clear}` | Borra la pantalla. |
| 20  | `INST/DEL` | `RETROCEDER` | `{delete}` | Elimina el carácter a la izquierda del cursor. |
| 148 | `SHIFT`+`INST/DEL` | `MAYUS`+`RETROCEDER` | `{148}` | Mueve los caracteres a la derecha para insertar un carácter. |
| 19  | `CLR/HOME` | `INICIO` | `{home}` | Mueve el cursor a la esquina superior izquierda. |
| 17  | `⇑ CRSR ⇓` | `ABAJO` | `{down}` | Mueve el cursor hacia abajo. |
| 29  | `⇐ CRSR ⇒` | `DERECHA` | `{right}` | Mueve el cursor hacia la derecha. |
| 145 | `SHIFT`+`⇑ CRSR ⇓` | `ARRIBA` | `{up}` | Mueve el cursor hacia la arriba. |
| 157 | `SHIFT`+`⇐ CRSR ⇒` | `IZQUIERDA` | `{left}` | Mueve el cursor hacia la izquierda. |

El siguiente grupo de códigos de escape nos permitirán cambiar el color de salida en la pantalla:

| PETSCII | C64        | VICE       | CBM prg Studio  | Descripción        |
|:-------:|:----------:|:----------:|:---------------:|--------------------|
| 144     | `CTRL`+`1` | `CTRL`+`1` | `{black}`       | Color negro        |
| 5       | `CTRL`+`2` | `CTRL`+`2` | `{white}`       | Color blanco       |
| 28      | `CTRL`+`3` | `CTRL`+`3` | `{red}`         | Color rojo         |
| 159     | `CTRL`+`4` | `CTRL`+`4` | `{cyan}`        | Color cian         |
| 156     | `CTRL`+`5` | `CTRL`+`5` | `{purple}`      | Color púrpura      |
| 30      | `CTRL`+`6` | `CTRL`+`6` | `{green}`       | Color verde        |
| 31      | `CTRL`+`7` | `CTRL`+`7` | `{blue}`        | Color azul         |
| 158     | `CTRL`+`8` | `CTRL`+`8` | `{yellow}`      | Color amarillo     |
| 129     | `C=`+`1`   | `TAB`+`1`  | `{orange}`      | Color naranja      |
| 149     | `C=`+`2`   | `TAB`+`2`  | `{brown}`       | Color marrón       |
| 150     | `C=`+`3`   | `TAB`+`3`  | `{pink}`        | Color rosa         |
| 151     | `C=`+`4`   | `TAB`+`4`  | `{dark gray}`   | Color gris oscuro  |
| 152     | `C=`+`5`   | `TAB`+`5`  | `{gray}`        | Color gris         |
| 153     | `C=`+`6`   | `TAB`+`6`  | `{light green}` | Color verde claro  |
| 154     | `C=`+`7`   | `TAB`+`7`  | `{light blue}`  | Color azul claro   |
| 155     | `C=`+`8`   | `TAB`+`8`  | `{light gray}`  | Color gris claro   |

Por último tenemos los siguientes códigos de escape que nos serán útiles de cara a trabajar con los valores obtenidos por el comando `GET`:

| PETSCII | C64              | VICE            | CBM prg Studio  |
|:-------:|:----------------:|:---------------:|:---------------:|
| 3       | `RUN/STOP`       | `ESC`           | `{ct c}`        |
| 13      | `RETURN`         | `ENTER`         | `{return}`      |
| 32      | `SPACE`          | `ESPACIO`       | ` `             |
| 133     | `F1`             | `F1`            | `{f1}`          |
| 134     | `F3`             | `F3`            | `{f3}`          |
| 135     | `F5`             | `F5`            | `{f5}`          |
| 136     | `F7`             | `F7`            | `{f7}`          |
| 137     | `SHIFT`+`F1`     | `F2`            | `{f2}`          |
| 138     | `SHIFT`+`F3`     | `F4`            | `{f4}`          |
| 139     | `SHIFT`+`F5`     | `F6`            | `{f6}`          |
| 140     | `SHIFT`+`F7`     | `F8`            | `{f8}`          |
| 141     | `SHIFT`+`RETURN` | `MAYUS`+`ENTER` | `{141}`         |

El código de escape de `RETURN` y `SHIFT`+`RETURN` tienen el mismo efecto.

### Abreviaturas

| Com.   | Abr.  | Com.   | Abr.  | Com.    | Abr.  | Com.   | Abr.  |
|:------:|:-----:|:------:|:-----:|:-------:|:-----:|:------:|:-----:|
| ABS    |A, ⇧+B | AND    |A, ⇧+N | ASC     |A, ⇧+S | ATN    |A, ⇧+T |
| CHR$   |C, ⇧+H | CLOSE  |CL, ⇧+O| CLR     |C, ⇧+L | CMD    |C, ⇧+M |
| CONT   |C, ⇧+O | COS    |       | DATA    |D, ⇧+A | DEF    |D, ⇧+E |
| DIM    |D, ⇧+I | END    |E, ⇧+N | EXP     |E, ⇧+X | FN     |       |
| FOR    |F, ⇧+O | FRE    |F, ⇧+R | GET     |G, ⇧+E | GET#   |       |
| GOSUB  |GO, ⇧+S| GOTO   |G, ⇧+O | IF      |       | INPUT  |       |
| INPUT# |I, ⇧+N | INT    |       | LEFT$   |LE, ⇧+F| LEN    |       |
| LET    |L, ⇧+E | LIST   |L, ⇧+I | LOAD    |L, ⇧+O | LOG    |       |
| MID$   |M, ⇧+I | NEW    |       | NEXT    |N, ⇧+E | NOT    |N, ⇧+O |
| ON     |       | OPEN   |O, ⇧+P | OR      |       | PEEK   |P, ⇧+E |
| POKE   |P, ⇧+O | POS    |       | PRINT   |?      | PRINT# |PR     |
| READ   |R, ⇧+E | REM    |       | RESTORE |RE, ⇧+S| RETURN |RE, ⇧+T|
| RIGHT$ |R, ⇧+I | RND    |R, ⇧+N | RUN     |R, ⇧+U | SAVE   |S, ⇧+A |
| SGN    |S, ⇧+G | SIN    |S, ⇧+I | SPC     |S, ⇧+P | SQR    |S, ⇧+Q |
| STATUS |ST     | STEP   |ST, ⇧+E| STOP    |S, ⇧+T | STR$   |ST, ⇧+R|
| SYS    |S, ⇧+Y | TAB    |T, ⇧+A | TAN     |       | THEN   |T, ⇧+H |
| TIME   |TI     | TIME$  |TI$    | TO      |       | USR    |U, ⇧+S |
| VAL    |V, ⇧+A | VERIFY |V, ⇧+E | WAIT    |W, ⇧+A |        |       |

## Lenguaje ensamblador

..

## Mapa de memoria

..

## KERNAL

..

## Interfaz gráfica

..

## Interfaz sonora

..

## Entrada y salida

### Teclado

..

### Joysticks

..
