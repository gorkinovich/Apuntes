# Commodore 64

## Introducción

El Commodore 64 fue una computadora de 8 bits lanzada en 1982 que gozó de gran popularidad. Este manual busca ser una referencia básica para poder programar juegos para esta máquina. Para ello el manual está dividido en tres documentos, empezando por el presente que contiene los aspectos de bajo nivel y del lenguaje ensamblador, seguido de un manual del [lenguaje BASIC V2](https://github.com/gorkinovich/Apuntes/blob/main/C64bas.md) y por último un [mapa de la memoria](https://github.com/gorkinovich/Apuntes/blob/main/C64mm.md) del C64.

## Especificaciones

| Elemento | Descripción |
|:--------:|-------------|
| CPU | MOS Technology 6510 <br/> - PAL: 0.9852486 MHz <br/> - NTSC: 1.0227273 MHz |
| RAM | 64 KB |
| ROM | 20 KB dividido en 3 chips <br/> - 8 KB BASIC V2 (\$A000-\$BFFF) <br/> - 8 KB KERNAL (\$E000-\$FFFF) <br/> - 4 KB FONTS (\$D000-\$DFFF) |
| Gráficos | VIC-II (MOS 6567/6569) <br/> - Resolución: 320x200 <br/> - Colores: 16 <br/> - Sprites: 8 de 24x21 (2 colores) o 12x21 (4 colores) <br/> - Interrupciones del rasterizado |
| Sonido | SID (MOS 6581) <br/> - 3x Osciladores (8 octavas, 16-4000 Hz) <br/> - 4x Formas de onda (sierra, triángulo, cuadrada y ruido) <br/> - Filtros: paso-bajo (LPF), paso-alto (HPF) y paso-banda (BPF) <br/> - Envolvente (ADSR) <br/> - Modulación por anillo (Ring Modulation) |
| E/S | - 2x CIA 6526 (joystick, teclado, RS-232, GPIO) <br/> - Bus en serie IEEE 488 (disqueteras e impresoras) <br/> - Cintas de casete (datasette) <br/> - Cartuchos de ROM |
| Disco | Commodore 1541 (5¼ SS-SD, 170 KB) <br/> - Formato: GCR <br/> - Máximo de ficheros: 144 <br/> - Sectores en total: 683 (664 libres) <br/> - Tamaño de sector: 256 bytes <br/> - Tamaño total: 174.848 bytes <br/> - Tamaño libre: 168.656 bytes (254 bytes/sector) <br/> - Velocidad: 300-400 B/s (C64 DOS) |

Para más información consulta la Wikipedia [inglesa](https://en.wikipedia.org/wiki/Commodore_64) o la [española](https://es.wikipedia.org/wiki/Commodore_64). También existe una [Wiki](https://www.c64-wiki.com/wiki/Main_Page) dedicada al C64 en inglés, donde poder consultar información sobre programar en la plataforma.

## Herramientas

+ [VICE](https://vice-emu.sourceforge.io): Emulador del C64 para PC.
+ [CCS64](http://www.ccs64.com): Emulador alternativo del C64 para PC.
+ [CBM prg Studio](https://www.ajordison.co.uk): Entorno de desarrollo para C64 (BASIC y ensamblador).
+ [CC65](https://cc65.github.io) ([GitHub](https://github.com/cc65/cc65)): Compilador de C para C64.
+ [CheeseCutter](https://theyamo.kapsi.fi/ccutter/) ([GitHub](https://github.com/theyamo/CheeseCutter)): Editor de música SID para C64.
+ [Multipaint](http://multipaint.kameli.net): Programa para dibujar usando los modos gráficos del C64.
+ [CharPad](https://subchristsoftware.itch.io/charpad-free-edition): Editor de mapas para el C64.
+ [SpritePad](https://csdb.dk/release/?id=132081): Editor de sprites para el C64.
+ [SpriteMate](https://www.spritemate.com/): Editor de sprites online para el C64.

El emulador VICE tiene varias configuraciones para el teclado: modo simbólico y modo posicional. Para esta documentación asumimos que se está usando el modo simbólico.

### Comandos útiles para trabajar

Si queremos compilar un programa con el CC65 usaremos:

```
cl65.exe -O -o game.prg -t c64 main.c
```

Para ejecutar luego el programa con VICE usaremos:

```
x64sc.exe game.prg
```

Si queremos generar un disquete virtual usaremos:

```
c1541 -format game,42 d64 GAME.D64 -attach GAME.D64 -write game.prg game
```

## Lenguaje ensamblador

..

| Bit | Flag | Nombre | 0 | 1 |
|:---:|:----:|:------:|:-:|:-:|
| 0 | C | Acarreo | No | Sí |
| 1 | Z | Cero | No es cero | Cero |
| 2 | I | IRQ | Activado | Desactivado |
| 3 | D | Modo Decimal | Deshabilitado | Habilitado |
| 4 | B | Comando BREAK | Sin BREAK | Con BREAK |
| 5 | - | - | - | - |
| 6 | V | Desbordamiento | No | Sí |
| 7 | N | Negativo | Positivo | Negativo |

..

## KERNAL

..

## Memoria

El C64 nos permite configurar la memoria para hacer visible los diferentes chips de ROM y RAM del sistema. Para ello tenemos que configurar los **bits 0-2** de la dirección de memoria **\$0001**, para configurar los bloques de memoria en \$A000-\$BFFF, \$D000-\$DFFF y \$E000-\$FFFF:

+ **000;100** = RAM visible en los tres bloques.  
+ **x01** = RAM visible en \$A000-\$BFFF y \$E000-\$FFFF.  
+ **x10** = RAM visible en \$A000-\$BFFF y KERNAL ROM visible en \$E000-\$FFFF.  
+ **x11** = BASIC ROM visible en \$A000-\$BFFF y KERNAL ROM visible en \$E000-\$FFFF.  
+ **0xx** = ROM de caracteres visible en \$D000-\$DFFF (excepto valor 000).  
+ **1xx** = Chips E/S visibles en \$D000-\$DFFF (excepto valor 100).

El valor por defecto al arrancar la máquina es el **111**, es decir, que la ROM de BASIC, el KERNAL y los chips de E/S son visibles. Es recomendable no desactivar el KERNAL, ni los chips de E/S, para poder trabajar con la máquina, pero en cuanto al interprete de BASIC se puede prescindir del mismo si no necesitamos de ninguna de sus subrutinas.

Por defecto la distribución de la memoria es la siguiente:

| Dirección | Descripción |
|:---------:|-------------|
| \$0000-\$00FF | Página cero. |
| \$0100-\$01FF | Pila de programa. |
| \$0200-\$03FF | Operaciones del sistema (BASIC y E/S). |
| \$0400-\$07FF | Buffer de pantalla y punteros de sprites. |
| \$0800-\$9FFF | Memoria libre. |
| \$A000-\$BFFF | ROM BASIC. |
| \$C000-\$CFFF | Memoria libre. |
| \$D000-\$D3FF | Chip VIC-II. |
| \$D400-\$D7FF | Chip SID. |
| \$D800-\$DBFF | Buffer de color de pantalla. |
| \$DC00-\$DDFF | Chips CIA1 y CIA2. |
| \$DE00-\$DFFF | E/S dispositivos externos opcionales. |
| \$E000-\$FFFF | ROM KERNAL. |

Por defecto tenemos 43.008 bytes de memoria libre disponible, que se pueden ampliar a 51.200 bytes si desactivamos la ROM de BASIC.

## Interfaz gráfica

El chip gráfico VIC-II tiene la capacidad de gestionar 16 KB de memoria RAM de los 64 KB que tiene en total el C64. Dentro del puerto A (**\$DD00**) de la CIA2, modificando los **bits 0-1**, podemos configurar cual de los cuatro bancos de memoria puede acceder el chip:

+ **00** = Banco 3 \$C000-\$FFFF (49152-65535).
+ **01** = Banco 2 \$8000-\$BFFF (32768-49151).
+ **10** = Banco 1 \$4000-\$7FFF (16384-32767)
+ **11** = Banco 0 \$0000-\$3FFF (0-16383).

Esto define los bits 14 y 15 de las direcciones a las que va a acceder el chip VIC-II. Una vez seleccionado el banco, podemos desde los registros en **\$D011** y **\$D016** cambiar la configuración de la pantalla:

| Bits | \$D011 | \$D016 |
|:----:|--------|--------|
| **0-2** | Desplazamiento horizontal raster. | Desplazamiento vertical raster. |
| **3** | Altura pantalla (**0** = 24; **1** = 25). | Ancho pantalla (**0** = 38; **1** = 40). |
| **4** | Pantalla: **0** = Apagada; **1** = Encendida. | Modo: **0** = Monocolor; **1** = Multicolor. |
| **5** | Modo: **0** = Carácter; **1** = Bitmap. | - |
| **6** | Modo fondo extendido: **0** = Desactivado; **1** = Activado. | - |
| **7** | Bit 8 de la línea actual del _raster_. | - |

Como se puede observar hay diferentes modos de pantalla, que se resumen en dos categorías:

+ **Modo carácter:** La unidad de pantalla es el carácter, que tiene un tamaño de **8x8 píxeles**. Podemos llamar a este modo también mapa de baldosas o *tilemap*, para ajustarlo a la terminología actual. El juego de caracteres, al que podemos llamar también *tileset*, es un conjunto de **256 elementos** a los que se apunta desde el buffer de pantalla. Cada *tile* requiere **8 bytes** de tamaño para definirlo, donde cada byte representa la fila dentro de la matriz de 8x8 y cada bit la columna dentro de dicha fila. Para definir un *tileset* completo necesitaremos 8x256 = **2.048 bytes** (2 KB).

+ **Modo bitmap:** La unidad de pantalla es el píxel, teniendo un total de **320x200 píxeles** el buffer de pantalla. Este modo consume muchos más recursos de la máquina, por ello muchos juegos lo utilizan sólo para la portada del juego y poco más.

Para el modo carácter hace falta el buffer de pantalla, el de color y el juego de caracteres. Para el modo bitmap hace falta el buffer de píxeles y el de color. Algunas de estas regiones se pueden cambiar de ubicación dentro del banco de memoria seleccionado, para ello usaremos el registro en **\$D018**:

| Bits | Descripción |
|:----:|-------------|
| **1-3** | Modo carácter: Ubicación del juego de caracteres (bits 11-13).<br/>Modo bitmap: Ubicación del buffer de píxeles (bit 13). |
| **4-7** | Ubicación del buffer de pantalla (bits 10-13). |

La ubicación del juego de caracteres en la memoria RAM, dependiendo del banco de memoria elegido en **\$DD00**, será:

| Valor | Banco 0 (11) | Banco 1 (10) | Banco 2 (01) | Banco 3 (00) |
|:-----:|--------------|--------------|--------------|--------------|
| **000** | \$0000-\$07FF | \$4000-\$47FF | \$8000-\$87FF | \$C000-\$C7FF |
| **001** | \$0800-\$0FFF | \$4800-\$4FFF | \$8800-\$8FFF | \$C800-\$CFFF |
| **010** | \$1000-\$17FF | \$5000-\$57FF | \$9000-\$97FF | \$D000-\$D7FF |
| **011** | \$1800-\$1FFF | \$5800-\$5FFF | \$9800-\$9FFF | \$D800-\$DFFF |
| **100** | \$2000-\$27FF | \$6000-\$67FF | \$A000-\$A7FF | \$E000-\$E7FF |
| **101** | \$2800-\$2FFF | \$6800-\$6FFF | \$A800-\$AFFF | \$E800-\$EFFF |
| **110** | \$3000-\$37FF | \$7000-\$77FF | \$B000-\$B7FF | \$F000-\$F7FF |
| **111** | \$3800-\$3FFF | \$7800-\$7FFF | \$B800-\$BFFF | \$F800-\$FFFF |

> **AVISO:** Con los valores **010** y **011** con el **banco 0** y **2** la implementación del chip VIC-II selecciona la ROM de caracteres en lugar de la RAM.

La ubicación del buffer de píxeles en la memoria RAM será:

| Valor | Banco 0 (11) | Banco 1 (10) | Banco 2 (01) | Banco 3 (00) |
|:-----:|--------------|--------------|--------------|--------------|
| **0xx** | \$0000-\$1FFF | \$4000-\$5FFF | \$8000-\$9FFF | \$C000-\$DFFF |
| **1xx** | \$2000-\$3FFF | \$6000-\$7FFF | \$A000-\$BFFF | \$E000-\$FFFF |

La ubicación del buffer de pantalla en la memoria RAM será:

| Valor | Banco 0 (11) | Banco 1 (10) | Banco 2 (01) | Banco 3 (00) |
|:-----:|--------------|--------------|--------------|--------------|
| **0000** | \$0000-\$03FF | \$4000-\$43FF | \$8000-\$83FF | \$C000-\$C3FF |
| **0001** | \$0400-\$07FF | \$4400-\$47FF | \$8400-\$87FF | \$C400-\$C7FF |
| **0010** | \$0800-\$0BFF | \$4800-\$4BFF | \$8800-\$8BFF | \$C800-\$CBFF |
| **0011** | \$0C00-\$0FFF | \$4C00-\$4FFF | \$8C00-\$8FFF | \$CC00-\$CFFF |
| **0100** | \$1000-\$13FF | \$5000-\$53FF | \$9000-\$93FF | \$D000-\$D3FF |
| **0101** | \$1400-\$17FF | \$5400-\$57FF | \$9400-\$97FF | \$D400-\$D7FF |
| **0110** | \$1800-\$1BFF | \$5800-\$5BFF | \$9800-\$9BFF | \$D800-\$DBFF |
| **0111** | \$1C00-\$1FFF | \$5C00-\$5FFF | \$9C00-\$9FFF | \$DC00-\$DFFF |
| **1000** | \$2000-\$23FF | \$6000-\$63FF | \$A000-\$A3FF | \$E000-\$E3FF |
| **1001** | \$2400-\$27FF | \$6400-\$67FF | \$A400-\$A7FF | \$E400-\$E7FF |
| **1010** | \$2800-\$2BFF | \$6800-\$6BFF | \$A800-\$ABFF | \$E800-\$EBFF |
| **1011** | \$2C00-\$2FFF | \$6C00-\$6FFF | \$AC00-\$AFFF | \$EC00-\$EFFF |
| **1100** | \$3000-\$33FF | \$7000-\$73FF | \$B000-\$B3FF | \$F000-\$F3FF |
| **1101** | \$3400-\$37FF | \$7400-\$77FF | \$B400-\$B7FF | \$F400-\$F7FF |
| **1110** | \$3800-\$3BFF | \$7800-\$7BFF | \$B800-\$BBFF | \$F800-\$FBFF |
| **1111** | \$3C00-\$3FFF | \$7C00-\$7FFF | \$BC00-\$BFFF | \$FC00-\$FFFF |

En caso de cambiar la ubicación del buffer de pantalla, si queremos utilizar las subrutinas de la terminal tendemos que actualizar el valor en la dirección **\$0288** (648), que por defecto tiene el valor `$04`.

### Colores del sistema

El C64 tiene 16 colores diferentes, cuyos valores van del 0 al 15, por lo que sólo requieren de 4 bits para definirlos. Por ejemplo:

```BASIC
10  REM VER LISTA DE COLORES
20  TB=1024:CB=55296:T=160
30  FOR I=0 TO 24
40  FOR J=0 TO 39
50  C=INT(J/5)
60  IF I>12 THEN C=C+8
70  POKE TB+(40*I+J),T
80  POKE CB+(40*I+J),C
90  NEXT J
100 NEXT I
110 GET K$
120 IF K$="" THEN 110
```

Este programa rellena el buffer de pantalla y de color para mostrar los 16 colores que soporta el chip gráfico VIC-II. Como resultado obtenemos la siguiente imagen:

<p align="center"><img src="https://gorkinovich.github.io/learn/C64-Colors.png" alt="Colores del C64"></p>

Además del buffer de color, podemos modificar el color del borde de la pantalla en la dirección **\$D020** y el del fondo en **\$D021**, independientemente del modo gráfico que esté seleccionado.

### Modo carácter

El modo carácter es un grupo de modos gráficos que gestionan el buffer de pantalla usando el carácter como unidad de información. Con este modo se puede representar, gastando poca memoria, los niveles de un juego. Hay tres modos de caracteres: el **estándar**, el **multicolor** y el de **color de fondo extendido**.

Los tres modos implican una representación de la pantalla como un tablero de **40x25 celdas**. Para ello hay un buffer de pantalla, que contiene los índices a los caracteres, y un buffer de color para la pantalla. Por defecto, el buffer de pantalla está en la región **\$0400-\$07E7**, aunque se puede reubicar si fuera necesario. El buffer de color siempre se encuentra en la región **\$D800-\$DBE7**. Ambos búferes tienen un tamaño de **1000 bytes**, de modo que la posición 0 es la esquina superior izquierda y la posición 999 es la esquina inferior derecha.

Cada celda de la pantalla es un byte, por lo tanto podemos disponer de 256 posibles valores que referenciar en el juego de caracteres, desde el 0 al 255. Como cada carácter tiene unas dimensiones de **8x8 píxeles**, la resolución de la pantalla es de **320x200 píxeles**. No hay que confundir los códigos de pantalla, que son índices dentro del juego de caracteres, con los códigos PETSCII. Algunas rutinas del KERNAL funcionan con PETSCII, por lo que habrá que tenerlo en cuenta a la hora de trabajar, e incluso tener subrutinas de conversión entre ambos tipos de códigos.

El **modo estándar** es el que está activado por defecto al arrancar la máquina. Este nos permite por cada celda seleccionar un *tile* y un color. Dentro de la **matriz** de **8x8** del ***tile***, si el píxel es **0** se utiliza el color de fondo (**\$D021**), si es **1** se utiliza el color almacenado en la celda del buffer de color.

El **modo multicolor** es similar al estándar, pero nos permite utilizar hasta 4 colores por celda formando bloques de dos píxeles en horizontal. Para aquellos familiarizados con el C64 recordarán los "píxeles gordos" en sus gráficos. La activación de este modo depende del valor que tenga la celda en el buffer de color:

+ **0-7:** Tile en modo monocolor con color 0-7.
+ **8-15:** Tile en modo multicolor con color 0-7.

Esto nos permite tener *tiles* para pintar texto y otros para pintar el mundo del juego, aunque conlleva perder los colores del 8 al 15 para el color de la celda. En este modo, cuando un ***tile*** se pinta en modo multicolor, en vez de tener una **matriz** de 8x8 tenemos una de **4x8**, donde cada elemento representa **2x1 píxeles**. Ahora los valores de cada "píxel gordo" en la matriz del *tile* son:

+ **00** = Color de fondo (**\$D021**).
+ **01** = Color de fondo extra 1 (**\$D022**).
+ **10** = Color de fondo extra 2 (**\$D023**).
+ **11** = Color de la celda en el buffer de color (**\$D800-\$DBE7**).

El **modo de color de fondo extendido** es una variación del modo estándar que nos permite tener cuatro colores de fondo distintos. Para ello, una vez es activado, el chip irá a la celda del buffer de pantalla y comprobará los **bits 6-7** para decidir qué color de fondo ha de usar. Los valores posibles son:

+ **00** = Color de fondo (**\$D021**).
+ **01** = Color de fondo extra 1 (**\$D022**).
+ **10** = Color de fondo extra 2 (**\$D023**).
+ **11** = Color de fondo extra 3 (**\$D024**).

La contrapartida de este sistema es que sólo podemos usar los 64 primeros elementos del mapa de caracteres, perdiendo la capacidad de usar los 192 restantes. Esto hace que este modo gráfico no sea especialmente popular.

Para poder ver en acción los diferentes modos tenemos el siguiente ejemplo:

```BASIC
10  REM INICIALIZAR VIC-II
20  POKE 53280,12 : REM COLOR BORDE
30  POKE 53281,0  : REM COLOR FONDO
40  POKE 53282,2  : REM COLOR EXTRA 1
50  POKE 53283,5  : REM COLOR EXTRA 2
60  POKE 53284,3  : REM COLOR EXTRA 3
70  POKE 646,1    : REM COLOR CURSOR
80  GOSUB 670
90  REM PINTAR MENU
100 PRINT "{147}{32*10}(VIC-II TEXT MODES)"
110 PRINT
120 PRINT "{32*4}F1:MONO F2:MULT F3:EXBG F4:BRCL"
130 PRINT "{32*4}F5:BGCL F6:E1CL F7:E2CL F8:E3CL"
140 PRINT "{32*3}0:CHCL 1-8:C0-C7 SHIFT+1-8:C8-C15"
150 REM PINTAR FUENTE
160 POKE 646,15
170 TB=1024  : REM BUFFER PANTALLA
180 CB=55296 : REM BUFFER COLOR
190 C=PEEK(646):T=0
200 FOR I=6 TO 13
210 FOR J=12 TO 27
220 POKE TB+(I*40+J),T
230 POKE CB+(I*40+J),C
240 POKE TB+((I+9)*40+J),T+128
250 POKE CB+((I+9)*40+J),C
260 T=T+1
270 NEXT J,I
280 REM LOGICA MENU
290 MD=0
300 GET K$
310 IF K$="{F1}" THEN GOSUB 670
320 IF K$="{F2}" THEN GOSUB 710
330 IF K$="{F3}" THEN GOSUB 750
340 IF K$="{F4}" THEN MD=1
350 IF K$="{F5}" THEN MD=2
360 IF K$="{F6}" THEN MD=3
370 IF K$="{F7}" THEN MD=4
380 IF K$="{F8}" THEN MD=5
390 IF K$="0" THEN MD=0
400 IF K$>="1" AND K$<="8" THEN C=ASC("1"):GOTO 460
410 IF K$>="!" AND K$<="(" THEN C=ASC("!")-8:GOTO 460
420 IF K$="/" THEN K$="'":C=ASC("!")-8:GOTO 460
430 IF K$="Q" THEN 550
440 GOTO 300
450 REM CAMBIAR EL COLOR
460 C=ASC(K$)-C
470 IF MD=0 THEN POKE 646,C:GOSUB 590
480 IF MD=1 THEN POKE 53280,C
490 IF MD=2 THEN POKE 53281,C
500 IF MD=3 THEN POKE 53282,C
510 IF MD=4 THEN POKE 53283,C
520 IF MD=5 THEN POKE 53284,C
530 GOTO 300
540 REM SALIR DEL PROGRAMA
550 PRINT"{147}"
560 GOSUB 670
570 END
580 REM ACTUALIZAR BUFFER COLOR
590 C=PEEK(646)
600 FOR I=6 TO 13
610 FOR J=12 TO 27
620 POKE CB+(I*40+J),C
630 POKE CB+((I+9)*40+J),C
640 NEXT J,I
650 RETURN
660 REM ACTIVAR MODO MONOCOLOR
670 POKE 53265,(PEEK(53265) AND 159)
680 POKE 53270,(PEEK(53270) AND 239)
690 RETURN
700 REM ACTIVAR MODO MULTICOLOR
710 POKE 53265,(PEEK(53265) AND 159)
720 POKE 53270,(PEEK(53270) AND 239) OR 16
730 RETURN
740 REM ACTIVAR MODO FONDO EXTENDIDO
750 POKE 53265,(PEEK(53265) AND 159) OR 64
760 POKE 53270,(PEEK(53270) AND 239)
770 RETURN
```

El ejemplo nos permite probar los diferentes modos de caracteres y modificar los diferentes colores de la pantalla. Además de su típica lentitud para actualizar el buffer de color y de pantalla, tiene añadida en la línea `420` una condición para facilitar la ejecución en el emulador VICE cuando el teclado está en modo simbólico, ya que el carácter que espera con `SHIFT+7` es la comilla simple (`'`).

### Modo bitmap

El modo bitmap es un grupo de modos gráficos que gestionan el buffer de pantalla usando el píxel como unidad de información. Con este modo se puede representar imágenes gráficas más complejas que en la sección anterior, pero su coste de memoria es superior. Hay dos modos bitmap: el **estándar** y el **multicolor**.

El tamaño de pantalla en el C64 es de 320x200 píxeles, que son 64.000 píxeles en total. Si quisiéramos que cada uno pudiera representar los 16 colores que tiene la máquina, necesitaríamos 4 bits por píxel y como consecuencia harían falta 32.000 bytes de memoria. Obviamente es un coste excesivo en memoria y por ello los ingenieros que diseñaron el C64 optaron por un método más restringido.

En el modo bitmap tenemos un **buffer de píxeles**, que será de 320x200 de tamaño, pero cada píxel es de un bit de tamaño, por lo tanto el buffer ocupará **8.000 bytes**. Aunque sería lógico pensar que la distribución de los píxeles del buffer es lineal con respecto las coordenadas de pantalla, lo cierto es que no es así sino de la siguiente manera:

| Y\X | 0 | 1 | … | 304 | 312 |
|:---:|---|---|---|-----|-----|
| **0** | B0 (0-7)<br/>B1 (8-15)<br/>B2 (16-23)<br/>B3 (24-31)<br/>B4 (32-39)<br/>B5 (40-47)<br/>B6 (48-55)<br/>B7 (56-63) | B8 (64-71)<br/>B9 (72-79)<br/>B10 (80-87)<br/>B11 (88-95)<br/>B12 (96-103)<br/>B13 (104-111)<br/>B14 (112-119)<br/>B15 (120-127) | … | B304 (2432-2439)<br/>B305 (2440-2447)<br/>B306 (2448-2455)<br/>B307 (2456-2463)<br/>B308 (2464-2471)<br/>B309 (2472-2479)<br/>B310 (2480-2487)<br/>B311 (2488-2495) | B312 (2496-2503)<br/>B313 (2504-2511)<br/>B314 (2512-2519)<br/>B315 (2520-2527)<br/>B316 (2528-2535)<br/>B317 (2536-2543)<br/>B318 (2544-2551)<br/>B319 (2552-2559) |
| **8** | B320 (2560-2567)<br/>B321 (2568-2575)<br/>B322 (2576-2583)<br/>B323 (2584-2591)<br/>B324 (2592-2599)<br/>B325 (2600-2607)<br/>B326 (2608-2615)<br/>B327 (2616-2623) | B328 (2624-2631)<br/>B329 (2632-2639)<br/>B330 (2640-2647)<br/>B331 (2648-2655)<br/>B332 (2656-2663)<br/>B333 (2664-2671)<br/>B334 (2672-2679)<br/>B335 (2680-2687) | … | B624 (4992-4999)<br/>B625 (5000-5007)<br/>B626 (5008-5015)<br/>B627 (5016-5023)<br/>B628 (5024-5031)<br/>B629 (5032-5039)<br/>B630 (5040-5047)<br/>B631 (5048-5055) | B632 (5056-5063)<br/>B633 (5064-5071)<br/>B634 (5072-5079)<br/>B635 (5080-5087)<br/>B636 (5088-5095)<br/>B637 (5096-5103)<br/>B638 (5104-5111)<br/>B639 (5112-5119) |
| … | … | … | … | … | … |
| **184** | B7360 (58880-58887)<br/>B7361 (58888-58895)<br/>B7362 (58896-58903)<br/>B7363 (58904-58911)<br/>B7364 (58912-58919)<br/>B7365 (58920-58927)<br/>B7366 (58928-58935)<br/>B7367 (58936-58943) | B7368 (58944-58951)<br/>B7369 (58952-58959)<br/>B7370 (58960-58967)<br/>B7371 (58968-58975)<br/>B7372 (58976-58983)<br/>B7373 (58984-58991)<br/>B7374 (58992-58999)<br/>B7375 (59000-59007) | … | B7664 (61312-61319)<br/>B7665 (61320-61327)<br/>B7666 (61328-61335)<br/>B7667 (61336-61343)<br/>B7668 (61344-61351)<br/>B7669 (61352-61359)<br/>B7670 (61360-61367)<br/>B7671 (61368-61375) | B7672 (61376-61383)<br/>B7673 (61384-61391)<br/>B7674 (61392-61399)<br/>B7675 (61400-61407)<br/>B7676 (61408-61415)<br/>B7677 (61416-61423)<br/>B7678 (61424-61431)<br/>B7679 (61432-61439) |
| **192** | B7680 (61440-61447)<br/>B7681 (61448-61455)<br/>B7682 (61456-61463)<br/>B7683 (61464-61471)<br/>B7684 (61472-61479)<br/>B7685 (61480-61487)<br/>B7686 (61488-61495)<br/>B7687 (61496-61503) | B7688 (61504-61511)<br/>B7689 (61512-61519)<br/>B7690 (61520-61527)<br/>B7691 (61528-61535)<br/>B7692 (61536-61543)<br/>B7693 (61544-61551)<br/>B7694 (61552-61559)<br/>B7695 (61560-61567) | … | B7984 (63872-63879)<br/>B7985 (63880-63887)<br/>B7986 (63888-63895)<br/>B7987 (63896-63903)<br/>B7988 (63904-63911)<br/>B7989 (63912-63919)<br/>B7990 (63920-63927)<br/>B7991 (63928-63935) | B7992 (63936-63943)<br/>B7993 (63944-63951)<br/>B7994 (63952-63959)<br/>B7995 (63960-63967)<br/>B7996 (63968-63975)<br/>B7997 (63976-63983)<br/>B7998 (63984-63991)<br/>B7999 (63992-63999) |

Como se puede intuir, la organización del buffer de píxeles sigue un patrón similar a la forma de trabajar del modo de caracteres. Una consecuencia de esto es que el número de colores disponibles en cada celda de 8x8 píxeles es limitado:

+ **Modo estándar:** 2 colores únicos por celda.
	+ **0** = *Nibble* bajo de la celda del buffer de pantalla.
	+ **1** = *Nibble* alto de la celda del buffer de pantalla.
+ **Modo multicolor:** 3 colores únicos por celda y 1 global a toda la pantalla.
	+ **00** = Color de fondo (**\$D021**).
	+ **01** = *Nibble* alto de la celda del buffer de pantalla.
	+ **10** = *Nibble* bajo de la celda del buffer de pantalla.
	+ **11** = Celda del buffer de color (**\$D800-\$DBE7**).

Primero, el término *nibble* se utiliza para designar a una de las dos mitades de un byte. Segundo, podemos deducir que el modo multicolor trabaja de forma similar al visto en el modo carácter, agrupando los píxeles en bloques de dos para definir 4 posibles colores por "píxel gordo".

No hay que olvidar que se debe configurar, en la dirección **\$D018**, la ubicación del buffer de píxeles dentro del banco de memoria seleccionado del chip gráfico. Esto es importante, porque la configuración por defecto posiblemente apunta al banco 0, situando el buffer de píxeles en los primeros 8.000 bytes de la memoria, donde el sistema tiene varias páginas de la memoria reservadas para diferentes operaciones, como el caso de la pila de programa. También es recomendable ubicar correctamente el buffer de pantalla para evitar colisiones con el de píxeles.

Por motivos de implementación de la arquitectura, el buffer de color no se puede cambiar de ubicación y siempre mantiene la misma dirección. Además, el chip VIC-II sólo puede leer los 4 bits más bajos, como parte de las optimizaciones con las que fue diseñado. Por esta decisión no se puede utilizar su *nibble* alto para añadir un cuarto color único al modo multicolor.

..

### Gestión de sprites

..

### Desplazamiento de pantalla

..

### Interrupciones gráficas

..

## Interfaz sonora

..

Tabla de valores para los niveles del ADSR:

| Nivel | Binario | Hexadecimal | Attack | Decay | Release |
|:-----:|:-------:|:-----------:|:------:|:-----:|:-------:|
| 0  | 0000 | 0 |   2 ms |   6 ms |   6 ms |
| 1  | 0001 | 1 |   8 ms |  24 ms |  24 ms |
| 2  | 0010 | 2 |  16 ms |  48 ms |  48 ms |
| 3  | 0011 | 3 |  24 ms |  72 ms |  72 ms |
| 4  | 0100 | 4 |  38 ms | 114 ms | 114 ms |
| 5  | 0101 | 5 |  56 ms | 168 ms | 168 ms |
| 6  | 0110 | 6 |  68 ms | 204 ms | 204 ms |
| 7  | 0111 | 7 |  80 ms | 240 ms | 240 ms |
| 8  | 1000 | 8 | 100 ms | 300 ms | 300 ms |
| 9  | 1001 | 9 | 250 ms | 750 ms | 750 ms |
| 10 | 1010 | A | 500 ms | 1.5 s  | 1.5 s  |
| 11 | 1011 | B | 800 ms | 2.4 s  | 2.4 s  |
| 12 | 1100 | C |   1 s  |   3 s  |   3 s  |
| 13 | 1101 | D |   3 s  |   9 s  |   9 s  |
| 14 | 1110 | E |   5 s  |  15 s  |  15 s  |
| 15 | 1111 | F |   8 s  |  24 s  |  24 s  |

..

## Entrada y salida

La gestión a bajo nivel de la E/S del C64 se realiza desde los chips CIA1 y CIA2. Con estos chips podemos controlar múltiples tipos de dispositivos, pero nos vamos a centrar en tres áreas: el teclado, los joysticks y la gestión de temporizadores.

### Direcciones de memoria

El chip CIA1 se puede acceder desde las siguientes direcciones de memoria:

| Dirección | Hexadecimal | Descripción |
|:---------:|:-----------:|-------------|
| 56320 | \$DC00 | Puerto A: Matriz de teclado y joystick 2. |
| 56321 | \$DC01 | Puerto B: Matriz de teclado y joystick 1. |
| 56322 | \$DC02 | Configuración del puerto A. |
| 56323 | \$DC03 | Configuración del puerto B. |
| 56324-56325 | \$DC04-\$DC05 | Cuenta atrás A. |
| 56326-56327 | \$DC06-\$DC07 | Cuenta atrás B. |
| 56328 | \$DC08 | TOD/Alarma: Décimas. |
| 56329 | \$DC09 | TOD/Alarma: Segundos. |
| 56330 | \$DC0A | TOD/Alarma: Minutos. |
| 56331 | \$DC0B | TOD/Alarma: Horas. |
| 56332 | \$DC0C | E/S de datos por el puerto de usuario. |
| 56333 | \$DC0D | Registro de control de interrupciones. |
| 56334 | \$DC0E | Registro de control de la cuenta atrás A. |
| 56335 | \$DC0F | Registro de control de la cuenta atrás B. |

En el mapa de memoria viene indicado cuáles son las posiciones de memoria del CIA2, que sirven para gestionar el puerto serie y el puerto de usuario entre otras cosas. Las interrupciones del CIA1 están conectadas al pin IRQ de la CPU, por lo tanto son enmascarables, mientras que las del CIA2 van al pin NMI y no son enmascarables. Las interrupciones se explican con más detalle en la sección del lenguaje ensamblador.

### Teclado

Para poder comprobar si una tecla está pulsada necesitamos consultar la matriz del teclado:

| A/B | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|:---------------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| **0** | `INST/DEL` | `RETURN` | `⇐CRSR⇒` | `F7` | `F1` | `F3` | `F5` | `⇑CRSR⇓` |
| **1** | `3` | `W` | `A` | `4` | `Z` | `S` | `E` | `SHIFT` (Iz.) |
| **2** | `5` | `R` | `D` | `6` | `C` | `F` | `T` | `X` |
| **3** | `7` | `Y` | `G` | `8` | `B` | `H` | `U` | `V` |
| **4** | `9` | `I` | `J` | `0` | `M` | `K` | `O` | `N` |
| **5** | `+` | `P` | `L` | `-` | `.` | `:` | `@` | `,` |
| **6** | `£` | `*` | `;` | `CLR/HOME` | `SHIFT` (De.) | `=` | `↑` | `/` |
| **7** | `1` | `←` | `CTRL` | `2` | `SPACE` | `C=` | `Q` | `RUN/STOP` |

Esta matriz cubre 64 de las 66 teclas del teclado (`RESTORE` está asociada al pin NMI y `SHIFT LOCK` está ligada al `SHIFT` izquierdo). Las filas son los bits que podemos configurar con el puerto A (\$DC00) y las columnas los bits que podemos leer del puerto B (\$DC01). Para ello hay que configurar el puerto A de escritura (\$DC02 = \$FF) y el puerto B de lectura (\$DC03 = \$00). Luego hay que asignar un 0 al bit que representa la fila correspondiente en el puerto A, para comprobar en el puerto B el estado de las teclas de dicha fila (0 = pulsada; 1 = no pulsada). Por ejemplo:

```BASIC
10  REM INICIALIZAR DATOS
20  DIM K$(7,7), M%(7)
30  N%=1
40  FOR I=0 TO 7
50  M%(I)=N%
60  N%=N%*2
70  NEXT I
80  K$(0,0)="DEL":K$(0,1)="RET":K$(0,2)="LRC":K$(0,3)="F7"
90  K$(0,4)="F1":K$(0,5)="F3":K$(0,6)="F5":K$(0,7)="UDC"
100 K$(1,0)="3":K$(1,1)="W":K$(1,2)="A":K$(1,3)="4"
110 K$(1,4)="Z":K$(1,5)="S":K$(1,6)="E":K$(1,7)="LSH"
120 K$(2,0)="5":K$(2,1)="R":K$(2,2)="D":K$(2,3)="6"
130 K$(2,4)="C":K$(2,5)="F":K$(2,6)="T":K$(2,7)="X"
140 K$(3,0)="7":K$(3,1)="Y":K$(3,2)="G":K$(3,3)="8"
150 K$(3,4)="B":K$(3,5)="H":K$(3,6)="U":K$(3,7)="V"
160 K$(4,0)="9":K$(4,1)="I":K$(4,2)="J":K$(4,3)="0"
170 K$(4,4)="M":K$(4,5)="K":K$(4,6)="O":K$(4,7)="N"
180 K$(5,0)="+":K$(5,1)="P":K$(5,2)="L":K$(5,3)="-"
190 K$(5,4)=".":K$(5,5)=":":K$(5,6)="@":K$(5,7)=","
200 K$(6,0)="{pound}":K$(6,1)="*":K$(6,2)=";":K$(6,3)="HOM"
210 K$(6,4)="RSH":K$(6,5)="=":K$(6,6)="^":K$(6,7)="/"
220 K$(7,0)="1":K$(7,1)="{arrow left}":K$(7,2)="CTR":K$(7,3)="2"
230 K$(7,4)="SPC":K$(7,5)="C=":K$(7,6)="Q":K$(7,7)="STP"
240 REM INICIALIZAR PANTALLA
250 PRINT "{clear}";
260 POKE 646,1    : REM COLOR CURSOR
270 POKE 53281,0  : REM COLOR FONDO
280 POKE 53280,12 : REM COLOR BORDE
290 FOR I=0 TO 7
300 FOR J=0 TO 7
310 PRINT TAB(5*J);K$(I,J);
320 NEXT J:PRINT
330 NEXT I
340 REM CONFIGURAR TECLADO
350 POKE 56322,255
360 POKE 56323,0
370 REM BUCLE PRINCIPAL
380 X=55296 : REM BUFFER DE COLOR
390 FOR I=0 TO 7
400 POKE 56320,255-M%(I)
410 K%=PEEK(56321)
420 FOR J=0 TO 7
430 C%=1:IF (K% AND M%(J))=0 THEN C%=10
440 POKE X,C%:X=X+1
450 POKE X,C%:X=X+1
460 POKE X,C%:X=X+3
470 NEXT J,I
480 GOTO 380
```

Aquí tenemos un programa BASIC que las líneas `20`-`230` inicializan la información que va a utilizar, las líneas `250`-`330` pinta en pantalla una tabla de las teclas de la matriz, las líneas `350`-`360` configura los puertos de la CIA1, por ultimo, el resto de líneas es un bucle infinito que selecciona en `400` la fila de la matriz a inspeccionar y en `410` obtiene su valor, para comprobar las teclas pulsadas de la fila y cambiar de color el texto si está pulsada la tecla. Lo que se puede observar es que intentar consultar el teclado así desde BASIC es muy lento e impracticable. Mientras que el mismo ejemplo en C, usando el compilador CC65:

```C
#include <stdio.h>
#include <conio.h>

#define POKE(A,X)  (*(unsigned char *)A) = (X)
#define PEEK(A)    (*(unsigned char *)A)
#define POKEW(A,X) (*(unsigned int *)A) = (X)
#define PEEKW(A)   (*(unsigned int *)A)

#define MAX_ROWS 8
#define MAX_COLS 8

void main() {
    unsigned int offset;
    unsigned char aux, row, col, mask[MAX_COLS], keys, color;
    
    aux = 1;
    for(col = 0; col < MAX_COLS; ++col) {
        mask[col] = aux;
        aux *= 2;
    }
    
    POKE(53272, 21); // Fuente mayúsculas
    POKE(  646,  1); // Color cursor
    POKE(53281,  0); // Color fondo
    POKE(53280, 12); // Color borde
    
    clrscr();
    printf("keyboard test!\n");
    printf("\n");
    printf("del  ret  lrc  f7   f1   f3   f5   udc\n");
    printf("3    w    a    4    z    s    e    lsh\n");
    printf("5    r    d    6    c    f    t    x\n");
    printf("7    y    g    8    b    h    u    v\n");
    printf("9    i    j    0    m    k    o    n\n");
    printf("+    p    l    -    .    :    @    ,\n");
    printf("%c    *    ;    hom  rsh  =    %c    /\n", 92, 94);
    printf("1    %c    ctr  2    spc  c=   q    run\n", 95);
    
    POKE(56322, 255); // CIA1 Puerto A en escritura
    POKE(56323,   0); // CIA1 Puerto B en lectura
    
    while(1) {
        offset = 55296 + 80;
        for(row = 0; row < MAX_ROWS; ++row) {
            POKE(56320, 255 - mask[row]);
            keys = PEEK(56321);
            for(col = 0; col < MAX_COLS; ++col) {
                if ((keys & mask[col]) == 0) {
                    color = 10;
                } else {
                    color = 1;
                }
                for(aux = 0; aux < 5; ++aux, ++offset) {
                    POKE(offset, color);
                }
            }
        }
    }
}
```

Podemos observar que sin embargo sí reacciona de forma fluida la captura de las pulsaciones de las teclas. Esto conlleva a recurrir desde BASIC al comando `GET` para la entrada por teclado, intentando no forzar la máquina demasiado frente a la lentitud del interprete.

### Joysticks

El C64 permite tener dos joysticks conectados, uno en cada puerto de control del lateral de la máquina. Para poder comprobar el estado del joystick del puerto de control 1 usaremos el puerto B (\$DC01) y para el joystick del puerto de control 2 usaremos el puerto A (\$DC00). En cada puerto podemos comprobar los cinco elementos del joystick (0 = pulsada; 1 = no pulsada):

+ **00011111** = Nada pulsado.
+ **00001111** = Disparo pulsado.
+ **00010111** = Derecha pulsado.
+ **00011011** = Izquierda pulsado.
+ **00011101** = Abajo pulsado.
+ **00011110** = Arriba pulsado.

En cuanto a la configuración de los puertos, es irrelevante ya que en modo escritura también se puede leer los puertos, además si configuramos como lectura el puerto A, no se podrán detectar las pulsaciones del teclado. Para comprenderlo mejor, veamos el siguiente ejemplo:

```BASIC
10  REM INICIALIZAR DATOS
20  DIM M%(4)
30  N%=1
40  FOR I=0 TO 4
50  M%(I)=N%
60  N%=N%*2
70  NEXT I
80  REM INICIALIZAR PANTALLA
90  PRINT "{clear}";
100 POKE 646,1    : REM COLOR CURSOR
110 POKE 53281,0  : REM COLOR FONDO
120 POKE 53280,12 : REM COLOR BORDE
130 PRINT "J1: U D L R F"
140 PRINT "J2: U D L R F"
150 REM CONFIGURAR TECLADO
160 POKE 56322,255
170 POKE 56323,0
180 REM BUCLE PRINCIPAL
190 X=55296+4  : REM BUFFER DE COLOR
200 Y=55296+44 : REM BUFFER DE COLOR
210 J2%=PEEK(56320)
220 J1%=PEEK(56321)
230 FOR I=0 TO 4
240 C%=1:IF (J1% AND M%(I))=0 THEN C%=10
250 POKE X,C%:X=X+2
260 C%=1:IF (J2% AND M%(I))=0 THEN C%=10
270 POKE Y,C%:Y=Y+2
280 NEXT I
290 GET K$
300 IF K$=" " then end
310 GOTO 190
```

Este es un programa BASIC que primero inicializa los datos en las líneas `20`-`70`, para luego mostrar por pantalla la información sobre los botones de los joysticks en las líneas `90`-`140`. De nuevo se configuran los puertos como en el ejemplo del teclado, para permitir que el interprete pueda luego realizar el comando `GET`. Por último, llegamos al bucle principal donde se va a cambiar el color del texto dependiendo de si los joysticks están pulsados, para ello en las líneas `210` y `220` se leen los puertos A y B, para comprobar en las líneas `240` y `260` si está pulsado algún botón o no. Finalmente se ejecuta el comando `GET`, para dar una opción al programa de salir del bucle.

### Temporizadores

El C64 permite controlar operaciones de tiempo mediante cuentas atrás (*timers*) o con el reloj del sistema (TOD). Existen dos cuentas atrás, A (\$DC04-\$DC05) y B (\$DC06-\$DC07), que son enteros de 16 bits sin signo, donde el primer byte es la parte menos significativa (*low*) y el segundo byte la más significativa (*high*). También existen dos registros de control para la cuenta atrás A (\$DC0E) y la cuenta atrás B (\$DC0F), que tienen las siguientes operaciones:

+ **(A/B) Bit 0:** Parar (**0**) o iniciar (**1**) cuenta atrás A/B.
+ **(A/B) Bit 3:** Acción al llegar a cero: reiniciar (**0**) o parar (**1**).
+ **(A) Bit 5:** Usar el reloj interno (**0**) o uno externo (**1**).
+ **(B) Bit 6,5:** Usar el reloj interno (**00**), uno externo (**01**) o contar llegadas a cero de la cuenta atrás A (**10**).
+ **(A) Bit 7:** Velocidad del TOD (**0** = 60 Hz; **1** = 50 Hz).
+ **(B) Bit 7:** Configurar la alarma del TOD (**1**).

Una vez configurada la CIA1, para trabajar con operaciones temporales, se deberá configurar la gestión de las interrupciones indicando en \$0314-\$0315 la dirección de la subrutina encargada de ello. Por defecto el sistema tiene una subrutina en \$EA31 para procesar interrupciones. Se podrá consultar desde la subrutina el registro de interrupciones de la CIA1 (\$DC0D), cuyos bits de lectura son:

+ **Bit 0:** La cuenta atrás A ha cruzado el valor cero.
+ **Bit 1:** La cuenta atrás B ha cruzado el valor cero.
+ **Bit 2:** El reloj del sistema (TOD) y la alarma son iguales.
+ **Bit 7:** Se ha producido una interrupción.

En cuanto a los bits de escritura tenemos:

+ **Bit 0:** Interrupción por cruzar el valor cero la cuenta atrás A.
+ **Bit 1:** Interrupción por cruzar el valor cero la cuenta atrás B.
+ **Bit 2:** Interrupción por la alarma del reloj del sistema.
+ **Bit 7:** Configuración de la máscara para las interrupciones:
	+ **Bits 0-6 = 0:** No se modifica la configuración de las interrupciones.
	+ **Bits 0-6 = 1:** Si Bit 7 = 0: Desactivar interrupciones; Si Bit 7 = 1: Activar interrupciones.

Por defecto están activadas las interrupciones, por lo que se podrá leer el registro para comprobar si se ha activado una interrupción o no.

El otro mecanismo es el reloj del sistema que nos da la hora del día (TOD), en formato hora, minutos, segundos y décimas de segundos. Los valores se almacenan en formato [BCD](https://es.wikipedia.org/wiki/Decimal_codificado_en_binario), aunque el bit 7 en el byte de la hora se utiliza para indicar si se trata de la hora AM (**0**) o PM (**1**). Con el registro de control en \$DC0F, si el bit 7 es **1** podemos escribir en los registros de la TOD la hora de la alarma, para poder obtener una interrupción cuando se alcance la hora del día indicada por la alarma. Tanto para la lectura de la TOD, como para la escritura, tiene la CIA un mecanismo de bloqueo (*latching*) que congela los registros hasta que las décimas sean leídas o escritas, para evitar inconsistencias. Este mecanismo no impide que internamente se siga actualizando la TOD, hasta que se haya escrito o leído entera la información accesible desde la memoria.

**NOTA:** El interprete y la terminal de BASIC usan internamente los temporizadores, por lo que su uso desde un programa escrito en BASIC puede derivar en problemas inesperados. En caso de necesitar gestionar el tiempo se puede usar la variable `TIME`. El manejo del tiempo mediante el uso de las CIAs deberá hacerse con programas en código máquina que activen la gestión de las interrupciones.

