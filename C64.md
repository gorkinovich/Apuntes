# Commodore 64

## Introducción

El Commodore 64 fue una computadora de 8 bits lanzada en 1982 que gozó de gran popularidad. Este manual busca ser una referencia básica para poder programar juegos para esta máquina. Para ello el manual está dividido en tres documentos, empezando por el presente que contiene los aspectos de bajo nivel y del lenguaje ensamblador, seguido de un manual del [lenguaje BASIC V2](https://github.com/gorkinovich/Apuntes/blob/main/C64bas.md) y por último un [mapa de la memoria](https://github.com/gorkinovich/Apuntes/blob/main/C64mm.md) del C64.

## Especificaciones

| Elemento | Descripción |
|:--------:|-------------|
| CPU | MOS Technology 6510 <br/> - PAL: 0.9852486 MHz <br/> - NTSC: 1.0227273 MHz |
| RAM | 64 KB |
| ROM | 20 KB dividido en 3 chips <br/> - 8 KB BASIC V2 (\$A000-\$BFFF) <br/> - 8 KB KERNAL (\$E000-\$FFFF) <br/> - 4 KB FONTS (\$D000-\$DFFF) |
| Gráficos | VIC-II (MOS 6567/6569) <br/> - Resolución: 320x200 <br/> - Colores: 16 <br/> - Sprites: 8 de 24x21 (2 colores) o 12x21 (4 colores) <br/> - Interrupciones del rasterizado |
| Sonido | SID (MOS 6581) <br/> - 3x Osciladores (8 octavas, 16-4000 Hz) <br/> - 4x Formas de onda (sierra, triángulo, cuadrada y ruido) <br/> - Filtros: paso-bajo (LPF), paso-alto (HPF) y paso-banda (BPF) <br/> - Envolvente (ADSR) <br/> - Modulación por anillo (Ring Modulation) |
| E/S | - 2x CIA 6526 (joystick, teclado, RS-232, GPIO) <br/> - Bus en serie IEEE 488 (disqueteras e impresoras) <br/> - Cintas de casete (datasette) <br/> - Cartuchos de ROM |
| Disco | Commodore 1541 (5¼ SS-SD, 170 KB) <br/> - Formato: GCR <br/> - Máximo de ficheros: 144 <br/> - Sectores en total: 683 (664 libres) <br/> - Tamaño de sector: 256 bytes <br/> - Tamaño total: 174.848 bytes <br/> - Tamaño libre: 168.656 bytes (254 bytes/sector) <br/> - Velocidad: 300-400 B/s (C64 DOS) |

Para más información consulta la Wikipedia [inglesa](https://en.wikipedia.org/wiki/Commodore_64) o la [española](https://es.wikipedia.org/wiki/Commodore_64). También existe una [Wiki](https://www.c64-wiki.com/wiki/Main_Page) dedicada al C64 en inglés, donde poder consultar información sobre programar en la plataforma.

## Herramientas

+ [VICE](https://vice-emu.sourceforge.io): Emulador del C64 para PC.
+ [CCS64](http://www.ccs64.com): Emulador alternativo del C64 para PC.
+ [CBM prg Studio](https://www.ajordison.co.uk): Entorno de desarrollo para C64 (BASIC y ensamblador).
+ [CC65](https://cc65.github.io) ([GitHub](https://github.com/cc65/cc65)): Compilador de C para C64.
+ [CheeseCutter](https://theyamo.kapsi.fi/ccutter/) ([GitHub](https://github.com/theyamo/CheeseCutter)): Editor de música SID para C64.
+ [Multipaint](http://multipaint.kameli.net): Programa para dibujar usando los modos gráficos del C64.
+ [CharPad](https://subchristsoftware.itch.io/charpad-free-edition): Editor de mapas para el C64.
+ [SpritePad](https://csdb.dk/release/?id=132081): Editor de sprites para el C64.
+ [SpriteMate](https://www.spritemate.com/): Editor de sprites online para el C64.

El emulador VICE tiene varias configuraciones para el teclado: modo simbólico y modo posicional. Para esta documentación asumimos que se está usando el modo simbólico.

### Comandos útiles para trabajar

Si queremos compilar un programa con el CC65 usaremos:

```
cl65.exe -O -o game.prg -t c64 main.c
```

Para ejecutar luego el programa con VICE usaremos:

```
x64sc.exe game.prg
```

Si queremos generar un disquete virtual usaremos:

```
c1541 -format game,42 d64 GAME.D64 -attach GAME.D64 -write game.prg game
```

## Lenguaje ensamblador

..

| Bit | Flag | Nombre | 0 | 1 |
|:---:|:----:|:------:|:-:|:-:|
| 0 | C | Acarreo | No | Sí |
| 1 | Z | Cero | No es cero | Cero |
| 2 | I | IRQ | Activado | Desactivado |
| 3 | D | Modo Decimal | Deshabilitado | Habilitado |
| 4 | B | Comando BREAK | Sin BREAK | Con BREAK |
| 5 | - | - | - | - |
| 6 | V | Desbordamiento | No | Sí |
| 7 | N | Negativo | Positivo | Negativo |

..

## KERNAL

..

## Interfaz gráfica

### Colores del sistema

..

### Modos gráficos

..

### Gestión de sprites

..

### Desplazamiento de pantalla

..

### Interrupciones gráficas

..

## Interfaz sonora

..

Tabla de valores para los niveles del ADSR:

| Nivel | Binario | Hexadecimal | Attack | Decay | Release |
|:-----:|:-------:|:-----------:|:------:|:-----:|:-------:|
| 0  | 0000 | 0 |   2 ms |   6 ms |   6 ms |
| 1  | 0001 | 1 |   8 ms |  24 ms |  24 ms |
| 2  | 0010 | 2 |  16 ms |  48 ms |  48 ms |
| 3  | 0011 | 3 |  24 ms |  72 ms |  72 ms |
| 4  | 0100 | 4 |  38 ms | 114 ms | 114 ms |
| 5  | 0101 | 5 |  56 ms | 168 ms | 168 ms |
| 6  | 0110 | 6 |  68 ms | 204 ms | 204 ms |
| 7  | 0111 | 7 |  80 ms | 240 ms | 240 ms |
| 8  | 1000 | 8 | 100 ms | 300 ms | 300 ms |
| 9  | 1001 | 9 | 250 ms | 750 ms | 750 ms |
| 10 | 1010 | A | 500 ms | 1.5 s  | 1.5 s  |
| 11 | 1011 | B | 800 ms | 2.4 s  | 2.4 s  |
| 12 | 1100 | C |   1 s  |   3 s  |   3 s  |
| 13 | 1101 | D |   3 s  |   9 s  |   9 s  |
| 14 | 1110 | E |   5 s  |  15 s  |  15 s  |
| 15 | 1111 | F |   8 s  |  24 s  |  24 s  |

..

## Entrada y salida

La gestión a bajo nivel de la E/S del C64 se realiza desde los chips CIA1 y CIA2. Con estos chips podemos controlar múltiples tipos de dispositivos, pero nos vamos a centrar en tres áreas: el teclado, los joysticks y la gestión de temporizadores.

### Direcciones de memoria

El chip CIA1 se puede acceder desde las siguientes direcciones de memoria:

| Dirección | Hexadecimal | Descripción |
|:---------:|:-----------:|-------------|
| 56320 | \$DC00 | Puerto A: Matriz de teclado y joystick 2. |
| 56321 | \$DC01 | Puerto B: Matriz de teclado y joystick 1. |
| 56322 | \$DC02 | Configuración del puerto A. |
| 56323 | \$DC03 | Configuración del puerto B. |
| 56324-56325 | \$DC04-\$DC05 | Cuenta atrás A. |
| 56326-56327 | \$DC06-\$DC07 | Cuenta atrás B. |
| 56328 | \$DC08 | TOD/Alarma: Décimas. |
| 56329 | \$DC09 | TOD/Alarma: Segundos. |
| 56330 | \$DC0A | TOD/Alarma: Minutos. |
| 56331 | \$DC0B | TOD/Alarma: Horas. |
| 56332 | \$DC0C | E/S de datos por el puerto de usuario. |
| 56333 | \$DC0D | Registro de control de interrupciones. |
| 56334 | \$DC0E | Registro de control de la cuenta atrás A. |
| 56335 | \$DC0F | Registro de control de la cuenta atrás B. |

En el mapa de memoria viene indicado cuáles son las posiciones de memoria del CIA2, que sirven para gestionar el puerto serie y el puerto de usuario entre otras cosas. Las interrupciones del CIA1 están conectadas al pin IRQ de la CPU, por lo tanto son enmascarables, mientras que las del CIA2 van al pin NMI y no son enmascarables. Las interrupciones se explican con más detalle en la sección del lenguaje ensamblador.

### Teclado

Para poder comprobar si una tecla está pulsada necesitamos consultar la matriz del teclado:

| A/B | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|:---------------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| **0** | `INST/DEL` | `RETURN` | `⇐CRSR⇒` | `F7` | `F1` | `F3` | `F5` | `⇑CRSR⇓` |
| **1** | `3` | `W` | `A` | `4` | `Z` | `S` | `E` | `SHIFT` (Iz.) |
| **2** | `5` | `R` | `D` | `6` | `C` | `F` | `T` | `X` |
| **3** | `7` | `Y` | `G` | `8` | `B` | `H` | `U` | `V` |
| **4** | `9` | `I` | `J` | `0` | `M` | `K` | `O` | `N` |
| **5** | `+` | `P` | `L` | `-` | `.` | `:` | `@` | `,` |
| **6** | `£` | `*` | `;` | `CLR/HOME` | `SHIFT` (De.) | `=` | `↑` | `/` |
| **7** | `1` | `←` | `CTRL` | `2` | `SPACE` | `C=` | `Q` | `RUN/STOP` |

Esta matriz cubre 64 de las 66 teclas del teclado (`RESTORE` está asociada al pin NMI y `SHIFT LOCK` está ligada al `SHIFT` izquierdo). Las filas son los bits que podemos configurar con el puerto A (\$DC00) y las columnas los bits que podemos leer del puerto B (\$DC01). Para ello hay que configurar el puerto A de escritura (\$DC02 = \$FF) y el puerto B de lectura (\$DC03 = \$00). Luego hay que asignar un 0 al bit que representa la fila correspondiente en el puerto A, para comprobar en el puerto B el estado de las teclas de dicha fila (0 = pulsada; 1 = no pulsada). Por ejemplo:

```BASIC
10  REM INICIALIZAR DATOS
20  DIM K$(7,7), M%(7)
30  N%=1
40  FOR I=0 TO 7
50  M%(I)=N%
60  N%=N%*2
70  NEXT I
80  K$(0,0)="DEL":K$(0,1)="RET":K$(0,2)="LRC":K$(0,3)="F7"
90  K$(0,4)="F1":K$(0,5)="F3":K$(0,6)="F5":K$(0,7)="UDC"
100 K$(1,0)="3":K$(1,1)="W":K$(1,2)="A":K$(1,3)="4"
110 K$(1,4)="Z":K$(1,5)="S":K$(1,6)="E":K$(1,7)="LSH"
120 K$(2,0)="5":K$(2,1)="R":K$(2,2)="D":K$(2,3)="6"
130 K$(2,4)="C":K$(2,5)="F":K$(2,6)="T":K$(2,7)="X"
140 K$(3,0)="7":K$(3,1)="Y":K$(3,2)="G":K$(3,3)="8"
150 K$(3,4)="B":K$(3,5)="H":K$(3,6)="U":K$(3,7)="V"
160 K$(4,0)="9":K$(4,1)="I":K$(4,2)="J":K$(4,3)="0"
170 K$(4,4)="M":K$(4,5)="K":K$(4,6)="O":K$(4,7)="N"
180 K$(5,0)="+":K$(5,1)="P":K$(5,2)="L":K$(5,3)="-"
190 K$(5,4)=".":K$(5,5)=":":K$(5,6)="@":K$(5,7)=","
200 K$(6,0)="{pound}":K$(6,1)="*":K$(6,2)=";":K$(6,3)="HOM"
210 K$(6,4)="RSH":K$(6,5)="=":K$(6,6)="^":K$(6,7)="/"
220 K$(7,0)="1":K$(7,1)="{arrow left}":K$(7,2)="CTR":K$(7,3)="2"
230 K$(7,4)="SPC":K$(7,5)="C=":K$(7,6)="Q":K$(7,7)="STP"
240 REM INICIALIZAR PANTALLA
250 PRINT "{clear}";
260 POKE 646,1    : REM COLOR CURSOR
270 POKE 53281,0  : REM COLOR FONDO
280 POKE 53280,12 : REM COLOR BORDE
290 FOR I=0 TO 7
300 FOR J=0 TO 7
310 PRINT TAB(5*J);K$(I,J);
320 NEXT J:PRINT
330 NEXT I
340 REM CONFIGURAR TECLADO
350 POKE 56322,255
360 POKE 56323,0
370 REM BUCLE PRINCIPAL
380 X=55296 : REM BUFFER DE COLOR
390 FOR I=0 TO 7
400 POKE 56320,255-M%(I)
410 K%=PEEK(56321)
420 FOR J=0 TO 7
430 C%=1:IF (K% AND M%(J))=0 THEN C%=10
440 POKE X,C%:X=X+1
450 POKE X,C%:X=X+1
460 POKE X,C%:X=X+3
470 NEXT J,I
480 GOTO 380
```

Aquí tenemos un programa BASIC que las líneas `20`-`230` inicializan la información que va a utilizar, las líneas `250`-`330` pinta en pantalla una tabla de las teclas de la matriz, las líneas `350`-`360` configura los puertos de la CIA1, por ultimo, el resto de líneas es un bucle infinito que selecciona en `400` la fila de la matriz a inspeccionar y en `410` obtiene su valor, para comprobar las teclas pulsadas de la fila y cambiar de color el texto si está pulsada la tecla. Lo que se puede observar es que intentar consultar el teclado así desde BASIC es muy lento e impracticable. Mientras que el mismo ejemplo en C, usando el compilador CC65:

```C
#include <stdio.h>
#include <conio.h>

#define POKE(A,X)  (*(unsigned char *)A) = (X)
#define PEEK(A)    (*(unsigned char *)A)
#define POKEW(A,X) (*(unsigned int *)A) = (X)
#define PEEKW(A)   (*(unsigned int *)A)

#define MAX_ROWS 8
#define MAX_COLS 8

void main() {
    unsigned int offset;
    unsigned char aux, row, col, mask[MAX_COLS], keys, color;
    
    aux = 1;
    for(col = 0; col < MAX_COLS; ++col) {
        mask[col] = aux;
        aux *= 2;
    }
    
    POKE(53272, 21); // Fuente mayúsculas
    POKE(  646,  1); // Color cursor
    POKE(53281,  0); // Color fondo
    POKE(53280, 12); // Color borde
    
    clrscr();
    printf("keyboard test!\n");
    printf("\n");
    printf("del  ret  lrc  f7   f1   f3   f5   udc\n");
    printf("3    w    a    4    z    s    e    lsh\n");
    printf("5    r    d    6    c    f    t    x\n");
    printf("7    y    g    8    b    h    u    v\n");
    printf("9    i    j    0    m    k    o    n\n");
    printf("+    p    l    -    .    :    @    ,\n");
    printf("%c    *    ;    hom  rsh  =    %c    /\n", 92, 94);
    printf("1    %c    ctr  2    spc  c=   q    run\n", 95);
    
    POKE(56322, 255); // CIA1 Puerto A en escritura
    POKE(56323,   0); // CIA1 Puerto B en lectura
    
    while(1) {
        offset = 55296 + 80;
        for(row = 0; row < MAX_ROWS; ++row) {
            POKE(56320, 255 - mask[row]);
            keys = PEEK(56321);
            for(col = 0; col < MAX_COLS; ++col) {
                if ((keys & mask[col]) == 0) {
                    color = 10;
                } else {
                    color = 1;
                }
                for(aux = 0; aux < 5; ++aux, ++offset) {
                    POKE(offset, color);
                }
            }
        }
    }
}
```

Podremos observar que sin embargo sí reacciona de forma fluida la captura de las pulsaciones de las teclas. Esto conlleva a recurrir desde BASIC al comando `GET` para la entrada por teclado, intentando no forzar la máquina demasiado frente a la lentitud del interprete.

### Joysticks

El C64 permite tener dos joysticks conectados, uno en cada puerto de control del lateral de la máquina. Para poder comprobar el estado del joystick del puerto de control 1 usaremos el puerto B (\$DC01) y para el joystick del puerto de control 2 usaremos el puerto A (\$DC00). En cada puerto podremos comprobar los cinco elementos del joystick (0 = pulsada; 1 = no pulsada):

+ **00011111** = Nada pulsado.
+ **00001111** = Disparo pulsado.
+ **00010111** = Derecha pulsado.
+ **00011011** = Izquierda pulsado.
+ **00011101** = Abajo pulsado.
+ **00011110** = Arriba pulsado.

En cuanto a la configuración de los puertos, es irrelevante ya que en modo escritura también se puede leer los puertos, además si configuramos como lectura el puerto A, no se podrán detectar las pulsaciones del teclado. Para comprenderlo mejor, veamos el siguiente ejemplo:

```BASIC
10  REM INICIALIZAR DATOS
20  DIM M%(4)
30  N%=1
40  FOR I=0 TO 4
50  M%(I)=N%
60  N%=N%*2
70  NEXT I
80  REM INICIALIZAR PANTALLA
90  PRINT "{clear}";
100 POKE 646,1    : REM COLOR CURSOR
110 POKE 53281,0  : REM COLOR FONDO
120 POKE 53280,12 : REM COLOR BORDE
130 PRINT "J1: U D L R F"
140 PRINT "J2: U D L R F"
150 REM CONFIGURAR TECLADO
160 POKE 56322,255
170 POKE 56323,0
180 REM BUCLE PRINCIPAL
190 X=55296+4  : REM BUFFER DE COLOR
200 Y=55296+44 : REM BUFFER DE COLOR
210 J2%=PEEK(56320)
220 J1%=PEEK(56321)
230 FOR I=0 TO 4
240 C%=1:IF (J1% AND M%(I))=0 THEN C%=10
250 POKE X,C%:X=X+2
260 C%=1:IF (J2% AND M%(I))=0 THEN C%=10
270 POKE Y,C%:Y=Y+2
280 NEXT I
290 GET K$
300 IF K$=" " then end
310 GOTO 190
```

Este es un programa BASIC que primero inicializa los datos en las líneas `20`-`70`, para luego mostrar por pantalla la información sobre los botones de los joysticks en las líneas `90`-`140`. De nuevo se configuran los puertos como en el ejemplo del teclado, para permitir que el interprete pueda luego realizar el comando `GET`. Por último, llegamos al bucle principal donde se va a cambiar el color del texto dependiendo de si los joysticks están pulsados, para ello en las líneas `210` y `220` se leen los puertos A y B, para comprobar en las líneas `240` y `260` si está pulsado algún botón o no. Finalmente se ejecuta el comando `GET`, para dar una opción al programa de salir del bucle.

### Temporizadores

El C64 permite controlar operaciones de tiempo mediante cuentas atrás (*timers*) o con el reloj del sistema (TOD). Existen dos cuentas atrás, A (\$DC04-\$DC05) y B (\$DC06-\$DC07), que son enteros de 16 bits sin signo, donde el primer byte es la parte menos significativa (*low*) y el segundo byte la más significativa (*high*). También existen dos registros de control para la cuenta atrás A (\$DC0E) y la cuenta atrás B (\$DC0F), que tienen las siguientes operaciones:

+ **(A/B) Bit 0:** Parar (**0**) o iniciar (**1**) cuenta atrás A/B.
+ **(A/B) Bit 3:** Acción al llegar a cero: reiniciar (**0**) o parar (**1**).
+ **(A) Bit 5:** Usar el reloj interno (**0**) o uno externo (**1**).
+ **(B) Bit 6,5:** Usar el reloj interno (**00**), uno externo (**01**) o contar llegadas a cero de la cuenta atrás A (**10**).
+ **(A) Bit 7:** Velocidad del TOD (**0** = 60 Hz; **1** = 50 Hz).
+ **(B) Bit 7:** Configurar la alarma del TOD (**1**).

Una vez configurada la CIA1, para trabajar con operaciones temporales, se deberá configurar la gestión de las interrupciones indicando en \$0314-\$0315 la dirección de la subrutina encargada de ello. Por defecto el sistema tiene una subrutina en \$EA31 para procesar interrupciones. Se podrá consultar desde la subrutina el registro de interrupciones de la CIA1 (\$DC0D), cuyos bits de lectura son:

+ **Bit 0:** La cuenta atrás A ha cruzado el valor cero.
+ **Bit 1:** La cuenta atrás B ha cruzado el valor cero.
+ **Bit 2:** El reloj del sistema (TOD) y la alarma son iguales.
+ **Bit 7:** Se ha producido una interrupción.

En cuanto a los bits de escritura tenemos:

+ **Bit 0:** Interrupción por cruzar el valor cero la cuenta atrás A.
+ **Bit 1:** Interrupción por cruzar el valor cero la cuenta atrás B.
+ **Bit 2:** Interrupción por la alarma del reloj del sistema.
+ **Bit 7:** Configuración de la máscara para las interrupciones:
	+ **Bits 0-6 = 0:** No se modifica la configuración de las interrupciones.
	+ **Bits 0-6 = 1:** Si Bit 7 = 0: Desactivar interrupciones; Si Bit 7 = 1: Activar interrupciones.

Por defecto están activadas las interrupciones, por lo que se podrá leer el registro para comprobar si se ha activado una interrupción o no.

El otro mecanismo es el reloj del sistema que nos da la hora del día (TOD), en formato hora, minutos, segundos y décimas de segundos. Los valores se almacenan en formato [BCD](https://es.wikipedia.org/wiki/Decimal_codificado_en_binario), aunque el bit 7 en el byte de la hora se utiliza para indicar si se trata de la hora AM (**0**) o PM (**1**). Con el registro de control en \$DC0F, si el bit 7 es **1** podremos escribir en los registros de la TOD la hora de la alarma, para poder obtener una interrupción cuando se alcance la hora del día indicada por la alarma. Tanto para la lectura de la TOD, como para la escritura, tiene la CIA un mecanismo de bloqueo (*latching*) que congela los registros hasta que las décimas sean leídas o escritas, para evitar inconsistencias. Este mecanismo no impide que internamente se siga actualizando la TOD, hasta que se haya escrito o leído entera la información accesible desde la memoria.

**NOTA:** El interprete y la terminal de BASIC usan internamente los temporizadores, por lo que su uso desde un programa escrito en BASIC puede derivar en problemas inesperados. En caso de necesitar gestionar el tiempo se puede usar la variable `TIME`. El manejo del tiempo mediante el uso de las CIAs deberá hacerse con programas en código máquina que activen la gestión de las interrupciones.

