# Commodore 64

El Commodore 64 fue una computadora de 8 bits lanzada en 1982 que gozó de gran popularidad. Este manual busca ser una referencia básica para poder programar juegos para esta máquina. Para ello el manual está dividido en tres documentos, empezando por el presente que contiene los aspectos de bajo nivel y del lenguaje ensamblador, seguido de un manual del [lenguaje BASIC V2](https://github.com/gorkinovich/Apuntes/blob/main/C64bas.md) y por último un [mapa de la memoria](https://github.com/gorkinovich/Apuntes/blob/main/C64mm.md) del C64.

## Especificaciones

| Elemento | Descripción |
|:--------:|-------------|
| CPU | MOS Technology 6510 <br/> - PAL: 0.9852486 MHz <br/> - NTSC: 1.0227273 MHz |
| RAM | 64 KB |
| ROM | 20 KB dividido en 3 chips <br/> - 8 KB BASIC V2 (\$A000-\$BFFF) <br/> - 8 KB KERNAL (\$E000-\$FFFF) <br/> - 4 KB FONTS (\$D000-\$DFFF) |
| Gráficos | VIC-II (MOS 6567/6569) <br/> - Resolución: 320x200 <br/> - Colores: 16 <br/> - Sprites: 8 de 24x21 (2 colores) o 12x21 (4 colores) <br/> - Interrupciones del rasterizado |
| Sonido | SID (MOS 6581) <br/> - 3x Osciladores (8 octavas, 16-4000 Hz) <br/> - 4x Formas de onda (sierra, triángulo, cuadrada y ruido) <br/> - Filtros: paso-bajo (LPF), paso-alto (HPF) y paso-banda (BPF) <br/> - Envolvente (ADSR) <br/> - Modulación por anillo (Ring Modulation) |
| E/S | - 2x CIA 6526 (joystick, teclado, RS-232, GPIO) <br/> - Bus en serie IEEE 488 (disqueteras e impresoras) <br/> - Cintas de casete (datasette) <br/> - Cartuchos de ROM |
| Disco | Commodore 1541 (5¼ SS-SD, 170 KB) <br/> - Formato: GCR <br/> - Máximo de ficheros: 144 <br/> - Sectores en total: 683 (664 libres) <br/> - Tamaño de sector: 256 bytes <br/> - Tamaño total: 174.848 bytes <br/> - Tamaño libre: 168.656 bytes (254 bytes/sector) <br/> - Velocidad: 300-400 B/s (C64 DOS) |

Para más información consulta la Wikipedia [inglesa](https://en.wikipedia.org/wiki/Commodore_64) o la [española](https://es.wikipedia.org/wiki/Commodore_64). También existe una [Wiki](https://www.c64-wiki.com/wiki/Main_Page) dedicada al C64 en inglés, donde poder consultar información sobre programar en la plataforma.

## Herramientas

+ [VICE](https://vice-emu.sourceforge.io): Emulador del C64 para PC.
+ [CCS64](http://www.ccs64.com): Emulador alternativo del C64 para PC.
+ [CBM prg Studio](https://www.ajordison.co.uk): Entorno de desarrollo para C64 (BASIC y ensamblador).
+ [CC65](https://cc65.github.io) ([GitHub](https://github.com/cc65/cc65)): Compilador de C para C64.
+ [CheeseCutter](https://theyamo.kapsi.fi/ccutter/) ([GitHub](https://github.com/theyamo/CheeseCutter)): Editor de música SID para C64.
+ [Multipaint](http://multipaint.kameli.net): Programa para dibujar usando los modos gráficos del C64.
+ [CharPad](https://subchristsoftware.itch.io/charpad-free-edition): Editor de mapas para el C64.
+ [SpritePad](https://csdb.dk/release/?id=132081): Editor de sprites para el C64.
+ [SpriteMate](https://www.spritemate.com/): Editor de sprites online para el C64.

El emulador VICE tiene varias configuraciones para el teclado: modo simbólico y modo posicional. Para esta documentación asumimos que se está usando el modo simbólico.

### Comandos útiles para trabajar

Si queremos compilar un programa con el CC65 usaremos:

```
cl65.exe -O -o game.prg -t c64 main.c
```

Para ejecutar luego el programa con VICE usaremos:

```
x64sc.exe game.prg
```

Si queremos generar un disquete virtual usaremos:

```
c1541 -format game,42 d64 GAME.D64 -attach GAME.D64 -write game.prg game
```

## Lenguaje ensamblador

..

| Bit | Flag | Nombre | 0 | 1 |
|:---:|:----:|:------:|:-:|:-:|
| 0 | C | Acarreo | No | Sí |
| 1 | Z | Cero | No es cero | Cero |
| 2 | I | IRQ | Activado | Desactivado |
| 3 | D | Modo Decimal | Deshabilitado | Habilitado |
| 4 | B | Comando BREAK | Sin BREAK | Con BREAK |
| 5 | - | - | - | - |
| 6 | V | Desbordamiento | No | Sí |
| 7 | N | Negativo | Positivo | Negativo |

..

## Memoria

El C64 nos permite configurar la memoria para hacer visible los diferentes chips de ROM y RAM del sistema. Para ello tenemos que configurar los **bits 0-2** de la dirección de memoria **\$0001**, para configurar los bloques de memoria en \$A000-\$BFFF, \$D000-\$DFFF y \$E000-\$FFFF:

+ **000;100** = RAM visible en los tres bloques.  
+ **x01** = RAM visible en \$A000-\$BFFF y \$E000-\$FFFF.  
+ **x10** = RAM visible en \$A000-\$BFFF y KERNAL ROM visible en \$E000-\$FFFF.  
+ **x11** = BASIC ROM visible en \$A000-\$BFFF y KERNAL ROM visible en \$E000-\$FFFF.  
+ **0xx** = ROM de caracteres visible en \$D000-\$DFFF (excepto valor 000).  
+ **1xx** = Chips E/S visibles en \$D000-\$DFFF (excepto valor 100).

El valor por defecto al arrancar la máquina es el **111**, es decir, que la ROM de BASIC, el KERNAL y los chips de E/S son visibles. Es recomendable no desactivar el KERNAL, ni los chips de E/S, para poder trabajar con la máquina, pero en cuanto al interprete de BASIC se puede prescindir del mismo si no necesitamos de ninguna de sus subrutinas.

Por defecto la distribución de la memoria es la siguiente:

| Dirección | Descripción |
|:---------:|-------------|
| \$0000-\$00FF | Página cero. |
| \$0100-\$01FF | Pila de programa. |
| \$0200-\$03FF | Operaciones del sistema (BASIC y E/S). |
| \$0400-\$07FF | Buffer de pantalla y punteros de *sprites*. |
| \$0800-\$9FFF | Memoria libre (38.912 bytes). |
| \$A000-\$BFFF | ROM BASIC. |
| \$C000-\$CFFF | Memoria libre (4.096 bytes). |
| \$D000-\$D3FF | Chip VIC-II. |
| \$D400-\$D7FF | Chip SID. |
| \$D800-\$DBFF | Buffer de color de pantalla. |
| \$DC00-\$DDFF | Chips CIA1 y CIA2. |
| \$DE00-\$DFFF | E/S dispositivos externos opcionales. |
| \$E000-\$FFFF | ROM KERNAL. |

Por defecto tenemos 43.008 bytes de memoria libre disponible, que se pueden ampliar a 51.200 bytes si desactivamos la ROM de BASIC.

## Interfaz gráfica

El chip gráfico VIC-II tiene la capacidad de gestionar 16 KB de memoria RAM de los 64 KB que tiene en total el C64. Dentro del puerto A (**\$DD00**) de la CIA2, modificando los **bits 0-1**, podemos configurar cual de los cuatro bancos de memoria puede acceder el chip:

+ **00** = Banco 3 \$C000-\$FFFF (49152-65535).
+ **01** = Banco 2 \$8000-\$BFFF (32768-49151).
+ **10** = Banco 1 \$4000-\$7FFF (16384-32767)
+ **11** = Banco 0 \$0000-\$3FFF (0-16383).

Esto define los bits 14 y 15 de las direcciones a las que va a acceder el chip VIC-II. Una vez seleccionado el banco, podemos desde los registros en **\$D011** y **\$D016** cambiar la configuración de la pantalla:

| Bits | \$D011 | \$D016 |
|:----:|--------|--------|
| **0-2** | Desplazamiento horizontal raster. | Desplazamiento vertical raster. |
| **3** | Altura pantalla (**0** = 24; **1** = 25). | Ancho pantalla (**0** = 38; **1** = 40). |
| **4** | Pantalla: **0** = Apagada; **1** = Encendida. | Modo: **0** = Monocolor; **1** = Multicolor. |
| **5** | Modo: **0** = Carácter; **1** = Bitmap. | - |
| **6** | Modo fondo extendido: **0** = Desactivado; **1** = Activado. | - |
| **7** | Bit 8 de la línea actual del _raster_. | - |

Como se puede observar hay diferentes modos de pantalla, que se resumen en dos categorías:

+ **Modo carácter:** La unidad de pantalla es el carácter, que tiene un tamaño de **8x8 píxeles**. Podemos llamar a este modo también mapa de baldosas o *tilemap*, para ajustarlo a la terminología actual. El juego de caracteres, al que podemos llamar también *tileset*, es un conjunto de **256 elementos** a los que se apunta desde el buffer de pantalla. Cada *tile* requiere **8 bytes** de tamaño para definirlo, donde cada byte representa la fila dentro de la matriz de 8x8 y cada bit la columna dentro de dicha fila. Para definir un *tileset* completo necesitaremos 8x256 = **2.048 bytes** (2 KB).

+ **Modo bitmap:** La unidad de pantalla es el píxel, teniendo un total de **320x200 píxeles** el buffer de pantalla. Este modo consume muchos más recursos de la máquina, por ello muchos juegos lo utilizan sólo para la portada del juego y poco más.

Para el modo carácter hace falta el buffer de pantalla, el de color y el juego de caracteres. Para el modo bitmap hace falta el buffer de píxeles y el de color. Algunas de estas regiones se pueden cambiar de ubicación dentro del banco de memoria seleccionado, para ello usaremos el registro en **\$D018**:

| Bits | Descripción |
|:----:|-------------|
| **1-3** | Modo carácter: Ubicación del juego de caracteres (bits 11-13).<br/>Modo bitmap: Ubicación del buffer de píxeles (bit 13). |
| **4-7** | Ubicación del buffer de pantalla (bits 10-13). |

La ubicación del juego de caracteres en la memoria RAM, dependiendo del banco de memoria elegido en **\$DD00**, será:

| Valor | Banco 0 (11) | Banco 1 (10) | Banco 2 (01) | Banco 3 (00) |
|:-----:|--------------|--------------|--------------|--------------|
| **000** | \$0000-\$07FF | \$4000-\$47FF | \$8000-\$87FF | \$C000-\$C7FF |
| **001** | \$0800-\$0FFF | \$4800-\$4FFF | \$8800-\$8FFF | \$C800-\$CFFF |
| **010** | \$1000-\$17FF | \$5000-\$57FF | \$9000-\$97FF | \$D000-\$D7FF |
| **011** | \$1800-\$1FFF | \$5800-\$5FFF | \$9800-\$9FFF | \$D800-\$DFFF |
| **100** | \$2000-\$27FF | \$6000-\$67FF | \$A000-\$A7FF | \$E000-\$E7FF |
| **101** | \$2800-\$2FFF | \$6800-\$6FFF | \$A800-\$AFFF | \$E800-\$EFFF |
| **110** | \$3000-\$37FF | \$7000-\$77FF | \$B000-\$B7FF | \$F000-\$F7FF |
| **111** | \$3800-\$3FFF | \$7800-\$7FFF | \$B800-\$BFFF | \$F800-\$FFFF |

> **AVISO:** Con los valores **010** y **011** con el **banco 0** y **2** la implementación del chip VIC-II selecciona la ROM de caracteres en lugar de la RAM.

La ubicación del buffer de píxeles en la memoria RAM será:

| Valor | Banco 0 (11) | Banco 1 (10) | Banco 2 (01) | Banco 3 (00) |
|:-----:|--------------|--------------|--------------|--------------|
| **0xx** | \$0000-\$1FFF | \$4000-\$5FFF | \$8000-\$9FFF | \$C000-\$DFFF |
| **1xx** | \$2000-\$3FFF | \$6000-\$7FFF | \$A000-\$BFFF | \$E000-\$FFFF |

La ubicación del buffer de pantalla en la memoria RAM será:

| Valor | Banco 0 (11) | Banco 1 (10) | Banco 2 (01) | Banco 3 (00) |
|:-----:|--------------|--------------|--------------|--------------|
| **0000** | \$0000-\$03FF | \$4000-\$43FF | \$8000-\$83FF | \$C000-\$C3FF |
| **0001** | \$0400-\$07FF | \$4400-\$47FF | \$8400-\$87FF | \$C400-\$C7FF |
| **0010** | \$0800-\$0BFF | \$4800-\$4BFF | \$8800-\$8BFF | \$C800-\$CBFF |
| **0011** | \$0C00-\$0FFF | \$4C00-\$4FFF | \$8C00-\$8FFF | \$CC00-\$CFFF |
| **0100** | \$1000-\$13FF | \$5000-\$53FF | \$9000-\$93FF | \$D000-\$D3FF |
| **0101** | \$1400-\$17FF | \$5400-\$57FF | \$9400-\$97FF | \$D400-\$D7FF |
| **0110** | \$1800-\$1BFF | \$5800-\$5BFF | \$9800-\$9BFF | \$D800-\$DBFF |
| **0111** | \$1C00-\$1FFF | \$5C00-\$5FFF | \$9C00-\$9FFF | \$DC00-\$DFFF |
| **1000** | \$2000-\$23FF | \$6000-\$63FF | \$A000-\$A3FF | \$E000-\$E3FF |
| **1001** | \$2400-\$27FF | \$6400-\$67FF | \$A400-\$A7FF | \$E400-\$E7FF |
| **1010** | \$2800-\$2BFF | \$6800-\$6BFF | \$A800-\$ABFF | \$E800-\$EBFF |
| **1011** | \$2C00-\$2FFF | \$6C00-\$6FFF | \$AC00-\$AFFF | \$EC00-\$EFFF |
| **1100** | \$3000-\$33FF | \$7000-\$73FF | \$B000-\$B3FF | \$F000-\$F3FF |
| **1101** | \$3400-\$37FF | \$7400-\$77FF | \$B400-\$B7FF | \$F400-\$F7FF |
| **1110** | \$3800-\$3BFF | \$7800-\$7BFF | \$B800-\$BBFF | \$F800-\$FBFF |
| **1111** | \$3C00-\$3FFF | \$7C00-\$7FFF | \$BC00-\$BFFF | \$FC00-\$FFFF |

En caso de cambiar la ubicación del buffer de pantalla, si queremos utilizar las subrutinas de la terminal tendemos que actualizar el valor en la dirección **\$0288** (648), que por defecto tiene el valor `$04`.

### Colores del sistema

El C64 tiene 16 colores diferentes, cuyos valores van del 0 al 15, por lo que sólo requieren de 4 bits para definirlos. Por ejemplo:

```BASIC
10  REM VER LISTA DE COLORES
20  TB=1024:CB=55296:T=160
30  FOR I=0 TO 24
40  FOR J=0 TO 39
50  C=INT(J/5)
60  IF I>12 THEN C=C+8
70  POKE TB+(40*I+J),T
80  POKE CB+(40*I+J),C
90  NEXT J
100 NEXT I
110 GET K$
120 IF K$="" THEN 110
```

Este programa rellena el buffer de pantalla y de color para mostrar los 16 colores que soporta el chip gráfico VIC-II. Como resultado obtenemos la siguiente imagen:

<p align="center"><img src="https://gorkinovich.github.io/learn/C64-Colors.png" alt="Colores del C64"></p>

Además del buffer de color, podemos modificar el color del borde de la pantalla en la dirección **\$D020** y el del fondo en **\$D021**, independientemente del modo gráfico que esté seleccionado.

### Modo carácter

El modo carácter es un grupo de modos gráficos que gestionan el buffer de pantalla usando el carácter como unidad de información. Con este modo se puede representar, gastando poca memoria, los niveles de un juego. Hay tres modos de caracteres: el **estándar**, el **multicolor** y el de **color de fondo extendido**.

Los tres modos implican una representación de la pantalla como un tablero de **40x25 celdas**. Para ello hay un buffer de pantalla, que contiene los índices a los caracteres, y un buffer de color para la pantalla. Por defecto, el buffer de pantalla está en la región **\$0400-\$07E7**, aunque se puede reubicar si fuera necesario. El buffer de color siempre se encuentra en la región **\$D800-\$DBE7**. Ambos búferes tienen un tamaño de **1.000 bytes**, de modo que la posición 0 es la esquina superior izquierda y la posición 999 es la esquina inferior derecha.

Cada celda de la pantalla es un byte, por lo tanto podemos disponer de 256 posibles valores que referenciar en el juego de caracteres, desde el 0 al 255. Como cada carácter tiene unas dimensiones de **8x8 píxeles**, la resolución de la pantalla es de **320x200 píxeles**. No hay que confundir los códigos de pantalla, que son índices dentro del juego de caracteres, con los códigos PETSCII. Algunas rutinas del KERNAL funcionan con PETSCII, por lo que habrá que tenerlo en cuenta a la hora de trabajar, e incluso tener subrutinas de conversión entre ambos tipos de códigos.

El **modo estándar** es el que está activado por defecto al arrancar la máquina. Este nos permite por cada celda seleccionar un *tile* y un color. Dentro de la **matriz** de **8x8** del ***tile***, si el píxel es **0** se utiliza el color de fondo (**\$D021**), si es **1** se utiliza el color almacenado en la celda del buffer de color.

El **modo multicolor** es similar al estándar, pero nos permite utilizar hasta 4 colores por celda formando bloques de dos píxeles en horizontal. Para aquellos familiarizados con el C64 recordarán los "píxeles gordos" en sus gráficos. La activación de este modo depende del valor que tenga la celda en el buffer de color:

+ **0-7:** Tile en modo monocolor con color 0-7.
+ **8-15:** Tile en modo multicolor con color 0-7.

Esto nos permite tener *tiles* para pintar texto y otros para pintar el mundo del juego, aunque conlleva perder los colores del 8 al 15 para el color de la celda. En este modo, cuando un ***tile*** se pinta en modo multicolor, en vez de tener una **matriz** de 8x8 tenemos una de **4x8**, donde cada elemento representa **2x1 píxeles**. Ahora los valores de cada "píxel gordo" en la matriz del *tile* son:

+ **00** = Color de fondo (**\$D021**).
+ **01** = Color de fondo extra 1 (**\$D022**).
+ **10** = Color de fondo extra 2 (**\$D023**).
+ **11** = Color de la celda en el buffer de color (**\$D800-\$DBE7**).

El **modo de color de fondo extendido** es una variación del modo estándar que nos permite tener cuatro colores de fondo distintos. Para ello, una vez es activado, el chip irá a la celda del buffer de pantalla y comprobará los **bits 6-7** para decidir qué color de fondo ha de usar. Los valores posibles son:

+ **00** = Color de fondo (**\$D021**).
+ **01** = Color de fondo extra 1 (**\$D022**).
+ **10** = Color de fondo extra 2 (**\$D023**).
+ **11** = Color de fondo extra 3 (**\$D024**).

La contrapartida de este sistema es que sólo podemos usar los 64 primeros elementos del mapa de caracteres, perdiendo la capacidad de usar los 192 restantes. Esto hace que este modo gráfico no sea especialmente popular.

Para poder ver en acción los diferentes modos tenemos el siguiente ejemplo:

```BASIC
10  REM INICIALIZAR VIC-II
20  POKE 53280,12 : REM COLOR BORDE
30  POKE 53281,0  : REM COLOR FONDO
40  POKE 53282,2  : REM COLOR EXTRA 1
50  POKE 53283,5  : REM COLOR EXTRA 2
60  POKE 53284,3  : REM COLOR EXTRA 3
70  POKE 646,1    : REM COLOR CURSOR
80  GOSUB 670
90  REM PINTAR MENU
100 PRINT "{147}{32*10}(VIC-II TEXT MODES)"
110 PRINT
120 PRINT "{32*4}F1:MONO F2:MULT F3:EXBG F4:BRCL"
130 PRINT "{32*4}F5:BGCL F6:E1CL F7:E2CL F8:E3CL"
140 PRINT "{32*3}0:CHCL 1-8:C0-C7 SHIFT+1-8:C8-C15"
150 REM PINTAR FUENTE
160 POKE 646,15
170 TB=1024  : REM BUFFER PANTALLA
180 CB=55296 : REM BUFFER COLOR
190 C=PEEK(646):T=0
200 FOR I=6 TO 13
210 FOR J=12 TO 27
220 POKE TB+(I*40+J),T
230 POKE CB+(I*40+J),C
240 POKE TB+((I+9)*40+J),T+128
250 POKE CB+((I+9)*40+J),C
260 T=T+1
270 NEXT J,I
280 REM LOGICA MENU
290 MD=0
300 GET K$
310 IF K$="{F1}" THEN GOSUB 670
320 IF K$="{F2}" THEN GOSUB 710
330 IF K$="{F3}" THEN GOSUB 750
340 IF K$="{F4}" THEN MD=1
350 IF K$="{F5}" THEN MD=2
360 IF K$="{F6}" THEN MD=3
370 IF K$="{F7}" THEN MD=4
380 IF K$="{F8}" THEN MD=5
390 IF K$="0" THEN MD=0
400 IF K$>="1" AND K$<="8" THEN C=ASC("1"):GOTO 460
410 IF K$>="!" AND K$<="(" THEN C=ASC("!")-8:GOTO 460
420 IF K$="/" THEN K$="'":C=ASC("!")-8:GOTO 460
430 IF K$="Q" THEN 550
440 GOTO 300
450 REM CAMBIAR EL COLOR
460 C=ASC(K$)-C
470 IF MD=0 THEN POKE 646,C:GOSUB 590
480 IF MD=1 THEN POKE 53280,C
490 IF MD=2 THEN POKE 53281,C
500 IF MD=3 THEN POKE 53282,C
510 IF MD=4 THEN POKE 53283,C
520 IF MD=5 THEN POKE 53284,C
530 GOTO 300
540 REM SALIR DEL PROGRAMA
550 PRINT"{147}"
560 GOSUB 670
570 END
580 REM ACTUALIZAR BUFFER COLOR
590 C=PEEK(646)
600 FOR I=6 TO 13
610 FOR J=12 TO 27
620 POKE CB+(I*40+J),C
630 POKE CB+((I+9)*40+J),C
640 NEXT J,I
650 RETURN
660 REM ACTIVAR MODO MONOCOLOR
670 POKE 53265,(PEEK(53265) AND 159)
680 POKE 53270,(PEEK(53270) AND 239)
690 RETURN
700 REM ACTIVAR MODO MULTICOLOR
710 POKE 53265,(PEEK(53265) AND 159)
720 POKE 53270,(PEEK(53270) AND 239) OR 16
730 RETURN
740 REM ACTIVAR MODO FONDO EXTENDIDO
750 POKE 53265,(PEEK(53265) AND 159) OR 64
760 POKE 53270,(PEEK(53270) AND 239)
770 RETURN
```

El ejemplo nos permite probar los diferentes modos de caracteres y modificar los diferentes colores de la pantalla. Además de su típica lentitud para actualizar el buffer de color y de pantalla, tiene añadida en la línea `420` una condición para facilitar la ejecución en el emulador VICE cuando el teclado está en modo simbólico, ya que el carácter que espera con `SHIFT+7` es la comilla simple (`'`).

### Modo bitmap

El modo bitmap es un grupo de modos gráficos que gestionan el buffer de pantalla usando el píxel como unidad de información. Con este modo se puede representar imágenes gráficas más complejas que en la sección anterior, pero su coste de memoria es superior. Hay dos modos bitmap: el **estándar** y el **multicolor**.

El tamaño de pantalla en el C64 es de 320x200 píxeles, que son 64.000 píxeles en total. Si quisiéramos que cada uno pudiera representar los 16 colores que tiene la máquina, necesitaríamos 4 bits por píxel y como consecuencia harían falta 32.000 bytes de memoria. Obviamente es un coste excesivo en memoria y por ello los ingenieros que diseñaron el C64 optaron por un método más restringido.

En el modo bitmap tenemos un **buffer de píxeles**, que será de 320x200 de tamaño, pero cada píxel es de un bit de tamaño, por lo tanto el buffer ocupará **8.000 bytes**. Aunque sería lógico pensar que la distribución de los píxeles del buffer es lineal con respecto las coordenadas de pantalla, lo cierto es que no es así sino de la siguiente manera:

| Y\X | 0 | 1 | … | 304 | 312 |
|:---:|---|---|---|-----|-----|
| **0** | B0 (0-7)<br/>B1 (8-15)<br/>B2 (16-23)<br/>B3 (24-31)<br/>B4 (32-39)<br/>B5 (40-47)<br/>B6 (48-55)<br/>B7 (56-63) | B8 (64-71)<br/>B9 (72-79)<br/>B10 (80-87)<br/>B11 (88-95)<br/>B12 (96-103)<br/>B13 (104-111)<br/>B14 (112-119)<br/>B15 (120-127) | … | B304 (2432-2439)<br/>B305 (2440-2447)<br/>B306 (2448-2455)<br/>B307 (2456-2463)<br/>B308 (2464-2471)<br/>B309 (2472-2479)<br/>B310 (2480-2487)<br/>B311 (2488-2495) | B312 (2496-2503)<br/>B313 (2504-2511)<br/>B314 (2512-2519)<br/>B315 (2520-2527)<br/>B316 (2528-2535)<br/>B317 (2536-2543)<br/>B318 (2544-2551)<br/>B319 (2552-2559) |
| **8** | B320 (2560-2567)<br/>B321 (2568-2575)<br/>B322 (2576-2583)<br/>B323 (2584-2591)<br/>B324 (2592-2599)<br/>B325 (2600-2607)<br/>B326 (2608-2615)<br/>B327 (2616-2623) | B328 (2624-2631)<br/>B329 (2632-2639)<br/>B330 (2640-2647)<br/>B331 (2648-2655)<br/>B332 (2656-2663)<br/>B333 (2664-2671)<br/>B334 (2672-2679)<br/>B335 (2680-2687) | … | B624 (4992-4999)<br/>B625 (5000-5007)<br/>B626 (5008-5015)<br/>B627 (5016-5023)<br/>B628 (5024-5031)<br/>B629 (5032-5039)<br/>B630 (5040-5047)<br/>B631 (5048-5055) | B632 (5056-5063)<br/>B633 (5064-5071)<br/>B634 (5072-5079)<br/>B635 (5080-5087)<br/>B636 (5088-5095)<br/>B637 (5096-5103)<br/>B638 (5104-5111)<br/>B639 (5112-5119) |
| … | … | … | … | … | … |
| **184** | B7360 (58880-58887)<br/>B7361 (58888-58895)<br/>B7362 (58896-58903)<br/>B7363 (58904-58911)<br/>B7364 (58912-58919)<br/>B7365 (58920-58927)<br/>B7366 (58928-58935)<br/>B7367 (58936-58943) | B7368 (58944-58951)<br/>B7369 (58952-58959)<br/>B7370 (58960-58967)<br/>B7371 (58968-58975)<br/>B7372 (58976-58983)<br/>B7373 (58984-58991)<br/>B7374 (58992-58999)<br/>B7375 (59000-59007) | … | B7664 (61312-61319)<br/>B7665 (61320-61327)<br/>B7666 (61328-61335)<br/>B7667 (61336-61343)<br/>B7668 (61344-61351)<br/>B7669 (61352-61359)<br/>B7670 (61360-61367)<br/>B7671 (61368-61375) | B7672 (61376-61383)<br/>B7673 (61384-61391)<br/>B7674 (61392-61399)<br/>B7675 (61400-61407)<br/>B7676 (61408-61415)<br/>B7677 (61416-61423)<br/>B7678 (61424-61431)<br/>B7679 (61432-61439) |
| **192** | B7680 (61440-61447)<br/>B7681 (61448-61455)<br/>B7682 (61456-61463)<br/>B7683 (61464-61471)<br/>B7684 (61472-61479)<br/>B7685 (61480-61487)<br/>B7686 (61488-61495)<br/>B7687 (61496-61503) | B7688 (61504-61511)<br/>B7689 (61512-61519)<br/>B7690 (61520-61527)<br/>B7691 (61528-61535)<br/>B7692 (61536-61543)<br/>B7693 (61544-61551)<br/>B7694 (61552-61559)<br/>B7695 (61560-61567) | … | B7984 (63872-63879)<br/>B7985 (63880-63887)<br/>B7986 (63888-63895)<br/>B7987 (63896-63903)<br/>B7988 (63904-63911)<br/>B7989 (63912-63919)<br/>B7990 (63920-63927)<br/>B7991 (63928-63935) | B7992 (63936-63943)<br/>B7993 (63944-63951)<br/>B7994 (63952-63959)<br/>B7995 (63960-63967)<br/>B7996 (63968-63975)<br/>B7997 (63976-63983)<br/>B7998 (63984-63991)<br/>B7999 (63992-63999) |

Como se puede intuir, la organización del buffer de píxeles sigue un patrón similar a la forma de trabajar del modo de caracteres. Una consecuencia de esto es que el número de colores disponibles en cada celda de 8x8 píxeles es limitado:

+ **Modo estándar:** 2 colores únicos por celda.
	+ **0** = *Nibble* bajo de la celda del buffer de pantalla.
	+ **1** = *Nibble* alto de la celda del buffer de pantalla.
+ **Modo multicolor:** 3 colores únicos por celda y 1 global a toda la pantalla.
	+ **00** = Color de fondo (**\$D021**).
	+ **01** = *Nibble* alto de la celda del buffer de pantalla.
	+ **10** = *Nibble* bajo de la celda del buffer de pantalla.
	+ **11** = Celda del buffer de color (**\$D800-\$DBE7**).

Primero, el término *nibble* se utiliza para designar a una de las dos mitades de un byte. Segundo, podemos deducir que el modo multicolor trabaja de forma similar al visto en el modo carácter, agrupando los píxeles en bloques de dos para definir 4 posibles colores por "píxel gordo".

No hay que olvidar que se debe configurar, en la dirección **\$D018**, la ubicación del buffer de píxeles dentro del banco de memoria seleccionado del chip gráfico. Esto es importante, porque la configuración por defecto posiblemente apunta al banco 0, situando el buffer de píxeles en los primeros 8.000 bytes de la memoria, donde el sistema tiene varias páginas de la memoria reservadas para diferentes operaciones, como el caso de la pila de programa. También es recomendable ubicar correctamente el buffer de pantalla para evitar colisiones con el de píxeles.

Por motivos de implementación de la arquitectura, el buffer de color no se puede cambiar de ubicación y siempre mantiene la misma dirección. Además, el chip VIC-II sólo puede leer los 4 bits más bajos, como parte de las optimizaciones con las que fue diseñado. Por esta decisión no se puede utilizar su *nibble* alto para añadir un cuarto color único al modo multicolor.

El siguiente ejemplo nos muestra cómo trabajar con el modo multicolor:

```BASIC
10  REM INICIALIZAR PROGRAMA
20  PRINT "{147}LOADING..."
30  POKE 53280,12     : REM COLOR BORDE
40  POKE 53281,0      : REM COLOR FONDO
50  POKE 646,1        : REM COLOR CURSOR
60  R%(0)=PEEK(56576) : REM PUERTO A CIA2
70  R%(1)=PEEK(53265) : REM REG1 VIC-II
80  R%(2)=PEEK(53270) : REM REG2 VIC-II
90  R%(3)=PEEK(53272) : REM MEM VIC-II
100 REM BORRAR BUFFER PIXEL
110 SB=23552:PB=24576:CB=55296
120 FOR I=0 TO 7999
130 POKE PB+I,0
140 PRINT "{19}LOADING...";STR$(INT(100*I/7999));"%"
150 NEXT I
160 REM MODIFICAR MODO GRAFICO
170 POKE 56576,(R%(0) AND 252) OR 2
180 POKE 53265,(R%(1) AND 223) OR 32
190 POKE 53270,(R%(2) AND 239) OR 16
200 POKE 53272,(R%(3) AND 1) OR 120
210 REM BUCLE SALVA PANTALLAS
220 X=0  : Y=0  : REM COORDENADAS
230 VX=2 : VY=1 : REM MOVIMIENTO
240 C=1  : P=1  : REM COLORES
250 REM CALCULAR POSICION PIXEL
260 CX=INT(X/8) : REM COLUMNA
270 DX=X-CX*8   : REM SUBCOLUMNA
280 CY=INT(Y/8) : REM FILA
290 DY=Y-CY*8   : REM SUBFILA
300 CP=CY*40+CX : REM CELDA
310 REM MODIFICAR BUFFER PIXEL
320 ZZ=PB+CP*8+DY
330 CB%=PEEK(ZZ)
340 IF DX>=0 AND DX<=1 THEN CB%=(CB% AND 63)+P*64
350 IF DX>=2 AND DX<=3 THEN CB%=(CB% AND 207)+P*16
360 IF DX>=4 AND DX<=5 THEN CB%=(CB% AND 243)+P*4
370 IF DX>=6 AND DX<=7 THEN CB%=(CB% AND 252)+P
380 POKE ZZ,CB%
390 REM MODIFICAR BUFFER COLOR
400 IF P=1 THEN ZZ=SB+CP : POKE ZZ,(PEEK(ZZ) AND 15)+C*16
410 IF P=2 THEN ZZ=SB+CP : POKE ZZ,(PEEK(ZZ) AND 240)+C
420 IF P=3 THEN ZZ=CB+CP : POKE ZZ,(PEEK(ZZ) AND 240)+C
430 P=P+1 : IF P>3  THEN P=1
440 C=C+1 : IF C>15 THEN C=1
450 REM MOVER COORDENADAS
460 IF X<=0   THEN X=0   : VX=2
470 IF X>=318 THEN X=318 : VX=-2
480 IF Y<=0   THEN Y=0   : VY=1
490 IF Y>=199 THEN Y=199 : VY=-1
500 X=X+VX : Y=Y+VY
510 REM COMPROBAR TECLADO
520 GET K$
530 IF K$="" THEN 260
540 REM FINALIZAR PROGRAMA
550 POKE 56576,R%(0)
560 POKE 53265,R%(1)
570 POKE 53270,R%(2)
580 POKE 53272,R%(3)
```

En `20`-`90` se cambian algunos colores y se guarda la configuración inicial del chip gráfico. En `120`-`150` se inicializa el buffer de píxeles para vaciarlo. En `170`-`200` se configura el chip gráfico para activar el modo bitmap multicolor, ubicando el buffer de píxeles en la segunda mitad del banco de memoria 1 (\$6000-\$7FFF) y el buffer de pantalla justo en los últimos 1024 bytes de la primera mitad (\$5C00-\$5FFF). En `260`-`300` se calcula la posición de la celda de la pantalla donde están las coordenadas `X` e `Y`. En `320`-`380` se calcula la posición en la memoria del bloque de píxeles a modificar, se modifica el valor y se guarda en la memoria. En `400`-`440` se actualiza los colores de pantalla. En `460`-`500` se mueven las coordenadas de pintado. Por último, en `520`-`530` se comprueba si se ha pulsado alguna tecla del teclado y en `550`-`580` se restaura la configuración inicial del chip gráfico.

> **AVISO:** Al trabajar con BASIC hay que tener en cuenta que la [memoria](https://www.c64-wiki.com/wiki/Memory_%28BASIC%29) ocupada por las cadenas de texto crece desde la dirección \$9FFF hacia abajo. Analizando el ejemplo vemos que sólo nos quedan 2.000 bytes de espacio hasta colisionar con el buffer de píxeles. En caso de colisión el programa puede desembocar en comportamientos inesperados y fallar en ejecución. Por ello hay que analizar con detenimiento la ubicación de los búferes del VIC-II.

### Gestión de sprites

Los *sprites* son un mecanismo del chip gráfico para pintar objetos en la pantalla que se pueden mover libremente. De este modo por un lado tenemos el fondo del escenario, representado por el buffer de pantalla o de píxeles, y por el otro las entidades que se mueven por la pantalla.

El C64 dispone de un máximo de **8 *sprites*** por hardware, pero existe una técnica llamada *multiplexación de sprites* que permite por software aumentar la cantidad de *sprites* simultáneos por pantalla.

Para poder **definir** un ***sprite*** tenemos que definir su matriz de **24x21 píxeles**. Cada píxel se define usando un bit, por lo tanto cada fila de 24 píxeles se define con 3 bytes, y multiplicando por 21 filas necesitamos **63 bytes** en total. Sin embargo, para que el VIC-II pueda localizar cualquier *sprite* en el banco de memoria seleccionado, estas matrices de puntos han de ubicarse en **direcciones** que sean **múltiplo** de **64**. Haciendo las cuentas nos sale que, dentro de un banco de memoria de 16 KB, pueden almacenarse hasta **256 *sprites***. Obviamente es imposible tener 256 *sprites*, porque necesitamos al menos 3 KB para el buffer de pantalla y el juego de caracteres si usamos el modo carácter, con el modo bitmap son 9 KB los que necesitamos.

Sabemos que el **buffer de pantalla** ocupa 1.000 bytes, pero se ubica en direcciones que son múltiplo de 1.024, es decir, que quedan 24 bytes aparentemente libres. En realidad, los últimos **8 bytes** de la región donde se ubica el buffer de pantalla, se utilizan como **punteros** para que el VIC-II pueda localizar los ***sprites*** en el banco de memoria. En la configuración por defecto el buffer de pantalla se encuentra en las direcciones **\$0400-\$07E7**, por lo tanto los punteros están en las direcciones **\$07F8-\$07FF**, donde la primera dirección corresponde al *sprite* 0 y la última al *sprite* 7.

El VIC-II tiene los siguientes registros para configurar los *sprites*:

| Dirección | Descripción |
|:---------:|-------------|
| \$D015 | Registro de activación de *sprites*:<br/>**0** = *Sprite* desactivado.<br/>**1** = *Sprite* activado. |
| \$D017 | Registro de doble altura de *sprites*:<br/>**0** = Alto normal.<br/>**1** = Alto doble. |
| \$D01B | Registro de prioridad de *sprites*:<br/>**0** = Pintar delante de la pantalla.<br/>**1** = Pintar detrás de la pantalla. |
| \$D01C | Registro de modo multicolor de *sprites*:<br/>**0** = Modo monocolor.<br/>**1** = Modo multicolor. |
| \$D01D | Registro de doble anchura de *sprites*:<br/>**0** = Ancho normal.<br/>**1** = Ancho doble. |

El bit 0 corresponde al *sprite* 0 y así sucesivamente hasta llegar al bit 7 que corresponde al *sprite* 7. El registro de prioridad determina si el *sprite* se debe pintar encima del contenido del buffer de pantalla o detrás del mismo, pero por encima del color de fondo. Es decir, que si un *sprite* se pinta por detrás de la "pantalla", este sólo será visible en aquellos píxeles que usen el color de fondo. Podemos alterar el ancho y el alto de un *sprite* duplicando sus dimensiones a la hora de ser pintado. Una vez configurado el *sprite* lo podemos activar para que sea pintado en pantalla.

Para poder mover por la pantalla los *sprites* el VIC-II necesita conocer las coordenadas y para ello tiene los siguientes registros:

| Dirección | Descripción |
|:---------:|-------------|
| \$D000 | Coordenada X del *sprite* 0 (bits del 0-7). |
| \$D001 | Coordenada Y del *sprite* 0. |
| \$D002 | Coordenada X del *sprite* 1 (bits del 0-7). |
| \$D003 | Coordenada Y del *sprite* 1. |
| \$D004 | Coordenada X del *sprite* 2 (bits del 0-7). |
| \$D005 | Coordenada Y del *sprite* 2. |
| \$D006 | Coordenada X del *sprite* 3 (bits del 0-7). |
| \$D007 | Coordenada Y del *sprite* 3. |
| \$D008 | Coordenada X del *sprite* 4 (bits del 0-7). |
| \$D009 | Coordenada Y del *sprite* 4. |
| \$D00A | Coordenada X del *sprite* 5 (bits del 0-7). |
| \$D00B | Coordenada Y del *sprite* 5. |
| \$D00C | Coordenada X del *sprite* 6 (bits del 0-7). |
| \$D00D | Coordenada Y del *sprite* 6. |
| \$D00E | Coordenada X del *sprite* 7 (bits del 0-7). |
| \$D00F | Coordenada Y del *sprite* 7. |
| \$D010 | Bit 8 de la coordenada X de los *sprites* 0-7. |

El **eje X** va desde el valor **0** al **511**, pero como un byte sólo contiene 256 valores hace falta un bit extra, que es el que se almacena en la dirección \$D010. El **eje Y** va desde el valor **0** al **255**. Por lo tanto, tenemos coordenadas que van de la posición **(0,0)**, en la esquina superior izquierda, a la **(511,255)**, en la esquina inferior derecha. Sin embargo, no todas las coordenadas son visibles en la pantalla, el **área visible** va desde la posición **(24,50)** a la **(343,249)**, que tiene unas dimensiones de **320x200 píxeles**.

Otra información que necesita el VIC-II es la información sobre los colores de los *sprites*. Para ello se usan los siguientes registros:

| Dirección | Descripción |
|:---------:|-------------|
| \$D025 | Color extra 1 de *sprites*. |
| \$D026 | Color extra 2 de *sprites*. |
| \$D027 | Color del *sprite* 0. |
| \$D028 | Color del *sprite* 1. |
| \$D029 | Color del *sprite* 2. |
| \$D02A | Color del *sprite* 3. |
| \$D02B | Color del *sprite* 4. |
| \$D02C | Color del *sprite* 5. |
| \$D02D | Color del *sprite* 6. |
| \$D02E | Color del *sprite* 7. |

Dependiendo de si el *sprite* está en modo **monocolor** o **multicolor**, tenemos dos o cuatro colores posibles. Como ya sospechará el lector, el modo multicolor agrupa los píxeles en bloques de dos, haciendo uso de los "píxeles gordos" que vimos en los modos gráficos. Por lo tanto, los valores de los píxeles son:

+ **Modo estándar:**
	+ **0** = Color transparente.
	+ **1** = Color del *sprite* (**\$D027-\$D02E**).
+ **Modo multicolor:**
	+ **00** = Color transparente.
	+ **01** = Color extra 1 (**\$D025**).
	+ **10** = Color del *sprite* (**\$D027-\$D02E**).
	+ **11** = Color extra 2 (**\$D026**).

El siguiente ejemplo muestra cómo trabajar con *sprites*

```BASIC
10  REM INICIALIZAR COLORES
20  POKE 53280,12  : REM COLOR BORDE
30  POKE 53281,0   : REM COLOR FONDO
40  POKE 646,1     : REM COLOR CURSOR
50  POKE 53285,15  : REM COLOR SPRITES EX1
60  POKE 53286,12  : REM COLOR SPRITES EX2
70  POKE 53287,1   : REM COLOR SPRITE 0
80  POKE 53288,2   : REM COLOR SPRITE 1
90  POKE 53289,5   : REM COLOR SPRITE 2
100 POKE 53290,6   : REM COLOR SPRITE 3
110 POKE 53291,1   : REM COLOR SPRITE 4
120 POKE 53292,2   : REM COLOR SPRITE 5
130 POKE 53293,5   : REM COLOR SPRITE 6
140 POKE 53294,6   : REM COLOR SPRITE 7
150 REM INICIALIZAR COORDENADAS
160 POKE 53248,79  : REM SPRITE X0
170 POKE 53249,90  : REM SPRITE Y0
180 POKE 53250,141 : REM SPRITE X1
190 POKE 53251,90  : REM SPRITE Y1
200 POKE 53252,203 : REM SPRITE X2
210 POKE 53253,90  : REM SPRITE Y2
220 POKE 53254,9   : REM SPRITE X3 (265)
230 POKE 53255,90  : REM SPRITE Y3
240 POKE 53256,79  : REM SPRITE X4
250 POKE 53257,197 : REM SPRITE Y4
260 POKE 53258,141 : REM SPRITE X5
270 POKE 53259,197 : REM SPRITE Y5
280 POKE 53260,203 : REM SPRITE X6
290 POKE 53261,197 : REM SPRITE Y6
300 POKE 53262,9   : REM SPRITE X7 (265)
310 POKE 53263,197 : REM SPRITE Y7
320 POKE 53264,136 : REM SPRITE X0-7 (B8)
330 REM CARGAR SPRITE EN MEMORIA
340 FOR I=0 TO 7
350 POKE 2040+I,255
360 NEXT I
370 FOR I=0 TO 62
380 READ A%
390 POKE 16320+I,A%
400 NEXT I
410 REM CONFIGURAR SPRITES
420 POKE 53271,0   : REM ALTO DOBLE SPRITES
430 POKE 53277,0   : REM ANCHO DOBLE SPRITES
440 POKE 53275,0   : REM PRIORIDAD SPRITES
450 POKE 53276,240 : REM MODO COLOR SPRITES
460 POKE 53269,255 : REM ACTIVAR SPRITES
470 REM PINTAR TEXTO PANTALLA
480 PRINT "{147}" : PRINT
490 PRINT "              {white}sprites test"
500 PRINT "{pink}"
510 FOR I=1 TO 18
520 PRINT "      {191*28}"
530 NEXT I
540 PRINT "{white}"
550 REM GESTION TECLADO
560 GET K$
570 IF K$="{F1}" THEN POKE 53271,1
580 IF K$="{F2}" THEN POKE 53271,0
590 IF K$="{F3}" THEN POKE 53277,1
600 IF K$="{F4}" THEN POKE 53277,0
610 IF K$="{F5}" THEN POKE 53275,1
620 IF K$="{F6}" THEN POKE 53275,0
630 IF K$="Q" OR K$=" " THEN 660
640 GOTO 560
650 REM FINALIZAR PROGRAMA
660 POKE 53269,0
670 PRINT "{147}"
680 REM SEÑOR CARTA (255:16320)
690 DATA 255,255,255
700 DATA 192,0,3
710 DATA 160,0,5
720 DATA 144,195,9
730 DATA 136,195,17
740 DATA 132,195,33
750 DATA 130,0,65
760 DATA 145,0,137
770 DATA 168,129,21
780 DATA 160,66,5
790 DATA 160,36,5
800 DATA 160,90,5
810 DATA 152,129,25
820 DATA 129,0,129
830 DATA 130,0,65
840 DATA 132,126,33
850 DATA 136,129,17
860 DATA 144,66,9
870 DATA 160,60,5
880 DATA 192,0,3
890 DATA 255,255,255
```

Primero se inicializan los colores, coordenadas, la matriz de píxeles del *sprite* y se termina de configurar todos los ocho *sprites* del hardware. Segundo se pinta en la pantalla un texto para poder comprobar el cambio de prioridad en el *sprite* 0. Con la gestión del teclado cambiamos algunas propiedades gráficas del *sprite* 0. Lo siguiente es desactivar los *sprites* en `660` y limpiar la pantalla. El último bloque son byte a byte la definición de la matriz de píxeles del *sprite*.

### Interrupciones gráficas

Existen varios elementos que pueden generar interrupciones en el chip VIC-II, para ello necesitamos tener en cuenta las siguientes direcciones de memoria:

| Dirección |  Descripción |
|:---------:|--------------|
| \$D011<br/>(Bit 7) | Lectura: Línea actual del *raster* (bit 8).<br/>Escritura: Línea de interrupción del *raster* (bit 8). |
| \$D012 | Lectura: Línea actual del *raster* (bits 0-7).<br/>Escritura: Línea de interrupción del *raster* (bits 0-7). |
| \$D019 | Registro de estado de interrupciones.<br/>Lectura:<br/>+ **Bit 0:** **1** = Línea de interrupción del *raster* alcanzada.<br/>+ **Bit 1:** **1** = Colisión *sprite*-fondo.<br/>+ **Bit 2:** **1** = Colisión *sprite*-*sprite*.<br/>+ **Bit 7:** **1** = Interrupción generada sin admitir.<br/>Escritura:<br/>+ **Bit 0:** **1** = Admitir interrupción de *raster*.<br/>+ **Bit 1:** **1** = Admitir interrupción de colisión *sprite*-fondo.<br/>+ **Bit 2:** **1** = Admitir interrupción de colisión *sprite*-*sprite*. |
| \$D01A | Registro de control de interrupciones:<br/>+ **Bit 0:** **1** = Activar interrupciones de *raster*.<br/>+ **Bit 1:** **1** = Activar interrupciones de colisión *sprite*-fondo.<br/>+ **Bit 2:** **1** = Activar interrupciones de colisión *sprite*-*sprite*. |
| \$D01E | Registro de colisión *sprite*-*sprite*.<br/>Lectura: **1** = El *sprite* ha colisionado con otro *sprite*.<br/>Escritura: **1** = Activar la detección de colisiones. |
| \$D01F | Registro de colisión *sprite*-fondo.<br/>Lectura: **1** = El *sprite* ha colisionado con el fondo.<br/>Escritura: **1** = Activar la detección de colisiones. |

Podemos controlar mediante interrupciones la localización del *raster* y las colisiones de los *sprites*. Una vez configurados los registros del chip gráfico, se deberá configurar la gestión de las interrupciones indicando en \$0314-\$0315 la dirección de la subrutina encargada de ello. Por defecto el sistema tiene una subrutina en \$EA31 para procesar interrupciones.

El ***raster*** representa el [rayo catódico](https://es.wikipedia.org/wiki/Rayos_cat%C3%B3dicos), en los [monitores CRT](https://es.wikipedia.org/wiki/Tubo_de_rayos_cat%C3%B3dicos), que recorre la pantalla actualizando cada punto de la imagen. La actualización recorre cada línea de la pantalla, de izquierda a derecha, y lo hace a una frecuencia de 50/60 Hz (PAL/NTSC). A partir de la **línea 250**, el rayo está fuera de la zona visible del VIC-II, limitándose a pintar el color del borde de la pantalla. Activando las interrupciones del *raster*, podemos actualizar la zona visible de la pantalla mientras no se esté actualizando el monitor, evitando así que parpadeen los gráficos de forma molesta. Para lograrlo hay que escribir, en los registros en **\$D011** (bit 7) y **\$D012**, el número de línea que debe generar la interrupción. Luego se activa el **bit 0** del registro **\$D01A** y cuando se invoque la rutina de gestión de interrupciones se consulta el **bit 0** de **\$D019** para saber si ha sido la causa de la interrupción actual, para finalmente escribir un **1** en el **bit 0** para comunicar que la interrupción ha sido admitida.

En un acto visionario, varias décadas antes, el chip gráfico del C64 nos alerta si un *sprite* ha colisionado con otro *sprite* o con el contenido de la pantalla. La **colisión** consiste en detectar si uno o más **píxeles activos**, es decir, que no valgan cero, de un ***sprite*** ocupan la misma posición que otros píxeles activos. Para ello, tenemos que activar en **\$D01E** y/o **\$D01F** los *sprites* que queremos vigilar. Una vez activado podemos consultar estos dos registros para comprobar si ha colisionado los *sprites* que hemos activado, si necesidad obligatoria de usar interrupciones. Una limitación de este mecanismo es, en caso de haber una colisión múltiple, que no sabremos con qué otro *sprite* ha colisionado. No obstante, es de gran utilidad esta herramienta. Si queremos utilizar interrupciones con las colisiones, tenemos que activar los bits correspondientes en el registro **\$D01A**. Entonces, cuando se invoque la rutina de gestión de interrupciones, consultaremos en **\$D019** los **bits 1** y **2**, para después escribir un **1** en ellos cuando queramos avisar al VIC-II que la interrupción ha sido admitida.

> **AVISO:** A diferencia de otras interrupciones, por ejemplo las provocadas por las CIA1 y CIA2, las generadas por el VIC-II requieren escribir en el registro \$D019 el valor 1 en aquellos bits de las interrupciones que hayamos gestionado. Si no se realiza esta acción, se seguirá invocando la rutina de gestión de interrupciones continuamente. Si sólo se van a manejar interrupciones del *raster*, se puede utilizar la instrucción `LSR` y comprobar con `BCS` si en efecto se ha producido una interrupción por el *raster*. El motivo por el que esto funciona es porque la instrucción `LSR`, que tiene 6 ciclos de ejecución, en el 4º lee de la memoria el valor, en el 5º escribe el valor leído en la memoria y rota el valor, y en el 6º escribe el nuevo valor obtenido.

### Desplazamiento de pantalla

..

## Interfaz sonora

..

Tabla de valores para los niveles del ADSR:

| Nivel | Binario | Hexadecimal | Attack | Decay | Release |
|:-----:|:-------:|:-----------:|:------:|:-----:|:-------:|
| 0  | 0000 | 0 |   2 ms |   6 ms |   6 ms |
| 1  | 0001 | 1 |   8 ms |  24 ms |  24 ms |
| 2  | 0010 | 2 |  16 ms |  48 ms |  48 ms |
| 3  | 0011 | 3 |  24 ms |  72 ms |  72 ms |
| 4  | 0100 | 4 |  38 ms | 114 ms | 114 ms |
| 5  | 0101 | 5 |  56 ms | 168 ms | 168 ms |
| 6  | 0110 | 6 |  68 ms | 204 ms | 204 ms |
| 7  | 0111 | 7 |  80 ms | 240 ms | 240 ms |
| 8  | 1000 | 8 | 100 ms | 300 ms | 300 ms |
| 9  | 1001 | 9 | 250 ms | 750 ms | 750 ms |
| 10 | 1010 | A | 500 ms | 1.5 s  | 1.5 s  |
| 11 | 1011 | B | 800 ms | 2.4 s  | 2.4 s  |
| 12 | 1100 | C |   1 s  |   3 s  |   3 s  |
| 13 | 1101 | D |   3 s  |   9 s  |   9 s  |
| 14 | 1110 | E |   5 s  |  15 s  |  15 s  |
| 15 | 1111 | F |   8 s  |  24 s  |  24 s  |

..

## Entrada y salida

La gestión a bajo nivel de la E/S del C64 se realiza desde los chips CIA1 y CIA2. Con estos chips podemos controlar múltiples tipos de dispositivos, pero nos vamos a centrar en tres áreas: el teclado, los joysticks y la gestión de temporizadores.

### Direcciones de memoria

El chip CIA1 se puede acceder desde las siguientes direcciones de memoria:

| Dirección | Hexadecimal | Descripción |
|:---------:|:-----------:|-------------|
| 56320 | \$DC00 | Puerto A: Matriz de teclado y joystick 2. |
| 56321 | \$DC01 | Puerto B: Matriz de teclado y joystick 1. |
| 56322 | \$DC02 | Configuración del puerto A. |
| 56323 | \$DC03 | Configuración del puerto B. |
| 56324-56325 | \$DC04-\$DC05 | Cuenta atrás A. |
| 56326-56327 | \$DC06-\$DC07 | Cuenta atrás B. |
| 56328 | \$DC08 | TOD/Alarma: Décimas. |
| 56329 | \$DC09 | TOD/Alarma: Segundos. |
| 56330 | \$DC0A | TOD/Alarma: Minutos. |
| 56331 | \$DC0B | TOD/Alarma: Horas. |
| 56332 | \$DC0C | E/S de datos por el puerto de usuario. |
| 56333 | \$DC0D | Registro de control de interrupciones. |
| 56334 | \$DC0E | Registro de control de la cuenta atrás A. |
| 56335 | \$DC0F | Registro de control de la cuenta atrás B. |

En el mapa de memoria viene indicado cuáles son las posiciones de memoria del CIA2, que sirven para gestionar el puerto serie y el puerto de usuario entre otras cosas. Las interrupciones del CIA1 están conectadas al pin IRQ de la CPU, por lo tanto son enmascarables, mientras que las del CIA2 van al pin NMI y no son enmascarables. Las interrupciones se explican con más detalle en la sección del lenguaje ensamblador.

### Teclado

Para poder comprobar si una tecla está pulsada necesitamos consultar la matriz del teclado:

| A/B | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|:---------------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| **0** | `INST/DEL` | `RETURN` | `⇐CRSR⇒` | `F7` | `F1` | `F3` | `F5` | `⇑CRSR⇓` |
| **1** | `3` | `W` | `A` | `4` | `Z` | `S` | `E` | `SHIFT` (Iz.) |
| **2** | `5` | `R` | `D` | `6` | `C` | `F` | `T` | `X` |
| **3** | `7` | `Y` | `G` | `8` | `B` | `H` | `U` | `V` |
| **4** | `9` | `I` | `J` | `0` | `M` | `K` | `O` | `N` |
| **5** | `+` | `P` | `L` | `-` | `.` | `:` | `@` | `,` |
| **6** | `£` | `*` | `;` | `CLR/HOME` | `SHIFT` (De.) | `=` | `↑` | `/` |
| **7** | `1` | `←` | `CTRL` | `2` | `SPACE` | `C=` | `Q` | `RUN/STOP` |

Esta matriz cubre 64 de las 66 teclas del teclado (`RESTORE` está asociada al pin NMI y `SHIFT LOCK` está ligada al `SHIFT` izquierdo). Las filas son los bits que podemos configurar con el puerto A (\$DC00) y las columnas los bits que podemos leer del puerto B (\$DC01). Para ello hay que configurar el puerto A de escritura (\$DC02 = \$FF) y el puerto B de lectura (\$DC03 = \$00). Luego hay que asignar un 0 al bit que representa la fila correspondiente en el puerto A, para comprobar en el puerto B el estado de las teclas de dicha fila (0 = pulsada; 1 = no pulsada). Por ejemplo:

```BASIC
10  REM INICIALIZAR DATOS
20  DIM K$(7,7), M%(7)
30  N%=1
40  FOR I=0 TO 7
50  M%(I)=N%
60  N%=N%*2
70  NEXT I
80  K$(0,0)="DEL":K$(0,1)="RET":K$(0,2)="LRC":K$(0,3)="F7"
90  K$(0,4)="F1":K$(0,5)="F3":K$(0,6)="F5":K$(0,7)="UDC"
100 K$(1,0)="3":K$(1,1)="W":K$(1,2)="A":K$(1,3)="4"
110 K$(1,4)="Z":K$(1,5)="S":K$(1,6)="E":K$(1,7)="LSH"
120 K$(2,0)="5":K$(2,1)="R":K$(2,2)="D":K$(2,3)="6"
130 K$(2,4)="C":K$(2,5)="F":K$(2,6)="T":K$(2,7)="X"
140 K$(3,0)="7":K$(3,1)="Y":K$(3,2)="G":K$(3,3)="8"
150 K$(3,4)="B":K$(3,5)="H":K$(3,6)="U":K$(3,7)="V"
160 K$(4,0)="9":K$(4,1)="I":K$(4,2)="J":K$(4,3)="0"
170 K$(4,4)="M":K$(4,5)="K":K$(4,6)="O":K$(4,7)="N"
180 K$(5,0)="+":K$(5,1)="P":K$(5,2)="L":K$(5,3)="-"
190 K$(5,4)=".":K$(5,5)=":":K$(5,6)="@":K$(5,7)=","
200 K$(6,0)="{pound}":K$(6,1)="*":K$(6,2)=";":K$(6,3)="HOM"
210 K$(6,4)="RSH":K$(6,5)="=":K$(6,6)="^":K$(6,7)="/"
220 K$(7,0)="1":K$(7,1)="{arrow left}":K$(7,2)="CTR":K$(7,3)="2"
230 K$(7,4)="SPC":K$(7,5)="C=":K$(7,6)="Q":K$(7,7)="STP"
240 REM INICIALIZAR PANTALLA
250 PRINT "{clear}";
260 POKE 646,1    : REM COLOR CURSOR
270 POKE 53281,0  : REM COLOR FONDO
280 POKE 53280,12 : REM COLOR BORDE
290 FOR I=0 TO 7
300 FOR J=0 TO 7
310 PRINT TAB(5*J);K$(I,J);
320 NEXT J:PRINT
330 NEXT I
340 REM CONFIGURAR TECLADO
350 POKE 56322,255
360 POKE 56323,0
370 REM BUCLE PRINCIPAL
380 X=55296 : REM BUFFER DE COLOR
390 FOR I=0 TO 7
400 POKE 56320,255-M%(I)
410 K%=PEEK(56321)
420 FOR J=0 TO 7
430 C%=1:IF (K% AND M%(J))=0 THEN C%=10
440 POKE X,C%:X=X+1
450 POKE X,C%:X=X+1
460 POKE X,C%:X=X+3
470 NEXT J,I
480 GOTO 380
```

Aquí tenemos un programa BASIC que las líneas `20`-`230` inicializan la información que va a utilizar, las líneas `250`-`330` pinta en pantalla una tabla de las teclas de la matriz, las líneas `350`-`360` configura los puertos de la CIA1, por ultimo, el resto de líneas es un bucle infinito que selecciona en `400` la fila de la matriz a inspeccionar y en `410` obtiene su valor, para comprobar las teclas pulsadas de la fila y cambiar de color el texto si está pulsada la tecla. Lo que se puede observar es que intentar consultar el teclado así desde BASIC es muy lento e impracticable. Mientras que el mismo ejemplo en C, usando el compilador CC65:

```C
#include <stdio.h>
#include <conio.h>

#define POKE(A,X)  (*(unsigned char *)A) = (X)
#define PEEK(A)    (*(unsigned char *)A)
#define POKEW(A,X) (*(unsigned int *)A) = (X)
#define PEEKW(A)   (*(unsigned int *)A)

#define MAX_ROWS 8
#define MAX_COLS 8

void main() {
    unsigned int offset;
    unsigned char aux, row, col, mask[MAX_COLS], keys, color;
    
    aux = 1;
    for(col = 0; col < MAX_COLS; ++col) {
        mask[col] = aux;
        aux *= 2;
    }
    
    POKE(53272, 21); // Fuente mayúsculas
    POKE(  646,  1); // Color cursor
    POKE(53281,  0); // Color fondo
    POKE(53280, 12); // Color borde
    
    clrscr();
    printf("keyboard test!\n");
    printf("\n");
    printf("del  ret  lrc  f7   f1   f3   f5   udc\n");
    printf("3    w    a    4    z    s    e    lsh\n");
    printf("5    r    d    6    c    f    t    x\n");
    printf("7    y    g    8    b    h    u    v\n");
    printf("9    i    j    0    m    k    o    n\n");
    printf("+    p    l    -    .    :    @    ,\n");
    printf("%c    *    ;    hom  rsh  =    %c    /\n", 92, 94);
    printf("1    %c    ctr  2    spc  c=   q    run\n", 95);
    
    POKE(56322, 255); // CIA1 Puerto A en escritura
    POKE(56323,   0); // CIA1 Puerto B en lectura
    
    while(1) {
        offset = 55296 + 80;
        for(row = 0; row < MAX_ROWS; ++row) {
            POKE(56320, 255 - mask[row]);
            keys = PEEK(56321);
            for(col = 0; col < MAX_COLS; ++col) {
                if ((keys & mask[col]) == 0) {
                    color = 10;
                } else {
                    color = 1;
                }
                for(aux = 0; aux < 5; ++aux, ++offset) {
                    POKE(offset, color);
                }
            }
        }
    }
}
```

Podemos observar que sin embargo sí reacciona de forma fluida la captura de las pulsaciones de las teclas. Esto conlleva a recurrir desde BASIC al comando `GET` para la entrada por teclado, intentando no forzar la máquina demasiado frente a la lentitud del interprete.

### Joysticks

El C64 permite tener dos joysticks conectados, uno en cada puerto de control del lateral de la máquina. Para poder comprobar el estado del joystick del puerto de control 1 usaremos el puerto B (\$DC01) y para el joystick del puerto de control 2 usaremos el puerto A (\$DC00). En cada puerto podemos comprobar los cinco elementos del joystick (0 = pulsada; 1 = no pulsada):

+ **00011111** = Nada pulsado.
+ **00001111** = Disparo pulsado.
+ **00010111** = Derecha pulsado.
+ **00011011** = Izquierda pulsado.
+ **00011101** = Abajo pulsado.
+ **00011110** = Arriba pulsado.

En cuanto a la configuración de los puertos, es irrelevante ya que en modo escritura también se puede leer los puertos, además si configuramos como lectura el puerto A, no se podrán detectar las pulsaciones del teclado. Para comprenderlo mejor, veamos el siguiente ejemplo:

```BASIC
10  REM INICIALIZAR DATOS
20  DIM M%(4)
30  N%=1
40  FOR I=0 TO 4
50  M%(I)=N%
60  N%=N%*2
70  NEXT I
80  REM INICIALIZAR PANTALLA
90  PRINT "{clear}";
100 POKE 646,1    : REM COLOR CURSOR
110 POKE 53281,0  : REM COLOR FONDO
120 POKE 53280,12 : REM COLOR BORDE
130 PRINT "J1: U D L R F"
140 PRINT "J2: U D L R F"
150 REM CONFIGURAR TECLADO
160 POKE 56322,255
170 POKE 56323,0
180 REM BUCLE PRINCIPAL
190 X=55296+4  : REM BUFFER DE COLOR
200 Y=55296+44 : REM BUFFER DE COLOR
210 J2%=PEEK(56320)
220 J1%=PEEK(56321)
230 FOR I=0 TO 4
240 C%=1:IF (J1% AND M%(I))=0 THEN C%=10
250 POKE X,C%:X=X+2
260 C%=1:IF (J2% AND M%(I))=0 THEN C%=10
270 POKE Y,C%:Y=Y+2
280 NEXT I
290 GET K$
300 IF K$=" " then end
310 GOTO 190
```

Este es un programa BASIC que primero inicializa los datos en las líneas `20`-`70`, para luego mostrar por pantalla la información sobre los botones de los joysticks en las líneas `90`-`140`. De nuevo se configuran los puertos como en el ejemplo del teclado, para permitir que el interprete pueda luego realizar el comando `GET`. Por último, llegamos al bucle principal donde se va a cambiar el color del texto dependiendo de si los joysticks están pulsados, para ello en las líneas `210` y `220` se leen los puertos A y B, para comprobar en las líneas `240` y `260` si está pulsado algún botón o no. Finalmente se ejecuta el comando `GET`, para dar una opción al programa de salir del bucle.

### Temporizadores

El C64 permite controlar operaciones de tiempo mediante cuentas atrás (*timers*) o con el reloj del sistema (TOD). Existen dos cuentas atrás, A (\$DC04-\$DC05) y B (\$DC06-\$DC07), que son enteros de 16 bits sin signo, donde el primer byte es la parte menos significativa (*low*) y el segundo byte la más significativa (*high*). También existen dos registros de control para la cuenta atrás A (\$DC0E) y la cuenta atrás B (\$DC0F), que tienen las siguientes operaciones:

+ **(A/B) Bit 0:** Parar (**0**) o iniciar (**1**) cuenta atrás A/B.
+ **(A/B) Bit 3:** Acción al llegar a cero: reiniciar (**0**) o parar (**1**).
+ **(A) Bit 5:** Usar el reloj interno (**0**) o uno externo (**1**).
+ **(B) Bit 6,5:** Usar el reloj interno (**00**), uno externo (**01**) o contar llegadas a cero de la cuenta atrás A (**10**).
+ **(A) Bit 7:** Velocidad del TOD (**0** = 60 Hz; **1** = 50 Hz).
+ **(B) Bit 7:** Configurar la alarma del TOD (**1**).

Una vez configurada la CIA1, para trabajar con operaciones temporales, se deberá configurar la gestión de las interrupciones indicando en \$0314-\$0315 la dirección de la subrutina encargada de ello. Por defecto el sistema tiene una subrutina en \$EA31 para procesar interrupciones. Se podrá consultar desde la subrutina el registro de interrupciones de la CIA1 (\$DC0D), cuyos bits de lectura son:

+ **Bit 0:** La cuenta atrás A ha cruzado el valor cero.
+ **Bit 1:** La cuenta atrás B ha cruzado el valor cero.
+ **Bit 2:** El reloj del sistema (TOD) y la alarma son iguales.
+ **Bit 7:** Se ha producido una interrupción.

En cuanto a los bits de escritura tenemos:

+ **Bit 0:** Interrupción por cruzar el valor cero la cuenta atrás A.
+ **Bit 1:** Interrupción por cruzar el valor cero la cuenta atrás B.
+ **Bit 2:** Interrupción por la alarma del reloj del sistema.
+ **Bit 7:** Configuración de la máscara para las interrupciones:
	+ **Bits 0-6 = 0:** No se modifica la configuración de las interrupciones.
	+ **Bits 0-6 = 1:** Si Bit 7 = 0: Desactivar interrupciones; Si Bit 7 = 1: Activar interrupciones.

Por defecto están activadas las interrupciones, por lo que se podrá leer el registro para comprobar si se ha activado una interrupción o no.

El otro mecanismo es el reloj del sistema que nos da la hora del día (TOD), en formato hora, minutos, segundos y décimas de segundos. Los valores se almacenan en formato [BCD](https://es.wikipedia.org/wiki/Decimal_codificado_en_binario), aunque el bit 7 en el byte de la hora se utiliza para indicar si se trata de la hora AM (**0**) o PM (**1**). Con el registro de control en \$DC0F, si el bit 7 es **1** podemos escribir en los registros de la TOD la hora de la alarma, para poder obtener una interrupción cuando se alcance la hora del día indicada por la alarma. Tanto para la lectura de la TOD, como para la escritura, tiene la CIA un mecanismo de bloqueo (*latching*) que congela los registros hasta que las décimas sean leídas o escritas, para evitar inconsistencias. Este mecanismo no impide que internamente se siga actualizando la TOD, hasta que se haya escrito o leído entera la información accesible desde la memoria.

> **AVISO:** El interprete y la terminal de BASIC usan internamente los temporizadores, por lo que su uso desde un programa escrito en BASIC puede derivar en problemas inesperados. En caso de necesitar gestionar el tiempo se puede usar la variable `TIME`. El manejo del tiempo mediante el uso de las CIAs deberá hacerse con programas en código máquina que activen la gestión de las interrupciones.

## KERNAL

Esta sección es un listado de algunas rutinas que podemos usar del KERNAL y del interprete de BASIC. Para más información sobre las rutinas del C64, en inglés, puedes consultar la siguiente [documentación](https://sta.c64.org/cbmdocs.html) o el [listado de memoria](http://unusedino.de/ec64/technical/aay/c64/) de la [ROM de BASIC](http://unusedino.de/ec64/technical/aay/c64/basromma.htm) y la [ROM del KERNAL](http://unusedino.de/ec64/technical/aay/c64/krnromma.htm).

### Rutinas principales

El KERNAL tiene en la zona final de su memoria una tabla de saltos a las diferentes rutinas de servicio que incorpora. Por ello para cada rutina tenemos dos direcciones: la de la tabla y la dirección real entre paréntesis, siendo esta última donde realmente se encuentra el código de la rutina.

| Nombre | Dirección | Entradas | Salidas | Usados | Descripción |
|:------:|:---------:|----------|---------|:------:|-------------|
| `SCINIT` | \$FF81 (\$FF5B) | - | - | A, X, Y | Inicializar VIC, asignar E/S por defecto (teclado/pantalla), borrar pantalla, configurar flag PAL/NTSC e interrupciones del *timer*. |
| `IOINIT` | \$FF84 (\$FDA3) | - | - | A, X | Inicializar CIAs y volumen SID; configurar la memoria; inicializar e iniciar interrupciones del *timer*. |
| `RAMTAS` | \$FF87 (\$FD50) | - | - | A, X, Y | Limpiar bloques de memoria \$0002-\$0101 y \$0200-\$03FF; iniciar test de memoria y asignar las direcciones de inicio y final de la memoria de programas BASIC; establecer el buffer de pantalla en \$0400 y el buffer de *datasette* en \$033C. |
| `RESTOR` | \$FF8A (\$FD15) | - | - | - | Rellenar la tabla de vectores en \$0314-\$0333 con los valores por defecto. |
| `VECTOR` | \$FF8D (\$FD1A) | **Carry:** **0** = Escribir (TV=TU); **1** = Leer (TU=TV).<br/>**X/Y:** Puntero tabla de usuario. | - | A, Y | Lee o escribe los valores de la tabla de vectores en \$0314-\$0333. |
| `SETMSG` | \$FF90 (\$FE18) | **A:** Valor flag. | - | - | Modifica el flag de mostrar errores del sistema (\$009D). |
| `LSTNSA` | \$FF93 (\$EDB9) | **A:** Dirección secundaria. | - | A | Envía un *LISTEN* a la dirección secundaria del puerto serie. (Debe llamarse `LISTEN` previamente.) |
| `TALKSA` | \$FF96 (\$EDC7) | **A:** Dirección secundaria. | - | A | Envía un *TALK* a la dirección secundaria del puerto serie. (Debe llamarse `TALK` previamente.) |
| `MEMBOT` | \$FF99 (\$FE25) | **Carry:** **0** = Escribir; **1** = Leer.<br/>**X/Y:** Dirección (Carry = 0). | **X/Y:** Dirección (Carry = 1). | X, Y | Lee o escribe la dirección de inicio de la memoria de trabajo de BASIC. |
| `MEMTOP` | \$FF9C (\$FE34) | **Carry:** **0** = Escribir; **1** = Leer.<br/>**X/Y:** Dirección (Carry = 0). | **X/Y:** Dirección (Carry = 1). | X, Y | Lee o escribe la dirección de final de la memoria de trabajo de BASIC. |
| `SCNKEY` | \$FF9F (\$EA87) | - | - | A, X, Y | Consulta el teclado, pone en \$00CB el código de matriz, en \$028D el estado actual de las teclas `SHIFT` y en el buffer de teclado el código PETSCII. |
| `SETTMO` | \$FFA2 (\$FE21) | **A:** Valor de *timeout*. | - | - | Configura el *timeout* del puerto serie. |
| `IECIN` | \$FFA5 (\$EE13) | - | **A:** Byte leído. | A | Lee un byte del puerto serie. (Debe llamarse `TALK` y `TALKSA` previamente.) |
| `IECOUT` | \$FFA8 (\$EDDD) | **A:** Byte para escribir. | - | - | Escribe un byte en el puerto serie.  (Debe llamarse `LISTEN` y `LSTNSA` previamente.) |
| `UNTALK` | \$FFAB (\$EDEF) | - | - | A | Enviar el comando *UNTALK* al puerto serie. |
| `UNLSTN` | \$FFAE (\$EDFE) | - | - | A | Enviar el comando *UNLISTEN* al puerto serie. |
| `LISTEN` | \$FFB1 (\$ED0C) | **A:** Número de dispositivo. | - | A | Enviar el comando *LISTEN* al puerto serie. |
| `TALK` | \$FFB4 (\$ED09) | **A:** Número de dispositivo. | - | A | Enviar el comando *TALK* al puerto serie. |
| `READST` | \$FFB7 (\$FE07) | - | **A:** Estado actual del dispositivo. | A | Obtiene el estado actual del dispositivo de E/S con el valor de la variable `STATUS`. (Para el RS-232, el estado es borrado.) |
| `SETLFS` | \$FFBA (\$FE00) | **A:** Número identificador.<br/>**X:** Número de dispositivo.<br/>**Y:** Modo o dirección secundaria. | - | - | Configura los parámetros del fichero para trabajar. |
| `SETNAM` | \$FFBD (\$FDF9) | **A:** Tamaño de la cadena.<br/>**X/Y:** Puntero a la cadena. | - | - | Configura el nombre del fichero para trabajar. |
| `OPEN` | \$FFC0 ((\$031A) = \$F34A) | - | - | A, X, Y | Abre un fichero. (Debe llamarse `SETLFS` y `SETNAM` previamente.) |
| `CLOSE` | \$FFC3 ((\$031C) = \$F291) | **A:** Número identificador. | - | A, X, Y | Cierra un fichero. |
| `CHKIN` | \$FFC6 ((\$031E) = \$F20E) | **X:** Número identificador. | - | A, X | Define un fichero como la entrada por defecto. (Debe llamarse `OPEN` previamente.) |
| `CHKOUT` | \$FFC9 ((\$0320) = \$F250) | **X:** Número identificador. | - | A, X | Define un fichero como la salida por defecto. (Debe llamarse `OPEN` previamente.) |
| `CLRCHN` | \$FFCC ((\$0322) = \$F333) | - | - | A, X | Cierra los ficheros de E/S por defecto (para el puerto serie se envía *UNTALK* y/o *UNLISTEN*). Restaura la E/S por defecto al teclado y pantalla. |
| `CHRIN` | \$FFCF ((\$0324); \$F157) | - | **A:** Byte leído. | A, Y | Lee un byte de la entrada por defecto, pero con el teclado lee una línea de la pantalla. (Si no es el teclado, debe llamarse `OPEN` y `CHKIN` previamente.) |
| `CHROUT` | \$FFD2 ((\$0326); \$F1CA) | **A:** Byte para escribir. | - | - | Escribe un byte en la salida por defecto. (Si no es la pantalla, debe llamarse `OPEN` y `CHKOUT` previamente.) |
| `LOAD` | \$FFD5 (\$F49E) | **A:** **0** = Cargar; **1-255** = Verificar.<br/>**X/Y:** Dirección de destino (si modo/DS = 0). | **Carry:** **0** = Éxito; **1** = Errores.<br/> **A:** Código error KERNAL (Carry = 1).<br/>**X/Y:** Dirección del último byte cargado/verificado (Carry = 0). | A, X, Y | Carga o verifica un fichero. (Debe llamarse `SETLFS` y `SETNAM` previamente.) |
| `SAVE` | \$FFD8 (\$F5DD) | **A:** Dirección en la página cero del registro con la dirección inicial del bloque de memoria a guardar.<br/>**X/Y:** Dirección final del bloque de memoria más 1. | **Carry:** **0** = Éxito; **1** = Errores.<br/>**A:** Código error KERNAL (Carry = 1). | A, X, Y | Guarda un fichero. (Debe llamarse `SETLFS` y `SETNAM` previamente.) |
| `SETTIM` | \$FFDB (\$F6E4) | **A/X/Y:** Nuevo valor. | - | - | Escribe el valor de `TIME` (\$00A0-\$00A2). |
| `RDTIM` | \$FFDE (\$F6DD) | - | **A/X/Y:** Valor actual. | A, X, Y | Lee el valor de `TIME` (\$00A0-\$00A2). |
| `STOP` | \$FFE1 ((\$0328) = \$F6ED) | - | **Zero:** **0** = Sin pulsar; **1** = Pulsada.<br/>**Carry:** **1** = Pulsada. | A, X | Consultar el estado de la tecla `RUN/STOP` (\$0091). Si está pulsada, invocar `CLRCHN` y limpiar el buffer de teclado. |
| `GETIN` | \$FFE4 ((\$032A) = \$F13E) | - | **A:** Byte leído. | A, X, Y | Lee un byte de la entrada por defecto. (Si no es el teclado, debe llamarse `OPEN` y `CHKIN` previamente.) |
| `CLALL` | \$FFE7 ((\$032C) = \$F32F) | - | - | A, X | Borra la tabla de ficheros e invoca a `CLRCHN`. |
| `UDTIM` | \$FFEA (\$F69B) | - | - | A, X | Actualiza la variable `TIME` (\$00A0-\$00A2) y el estado de la tecla `RUN/STOP` (\$0091). |
| `SCREEN` | \$FFED (\$E505) | - | **X:** Columnas (40).<br/>**Y:** Filas (25). | X, Y | Obtiene el número de filas y columnas de la pantalla. |
| `PLOT` | \$FFF0 (\$E50A) | **Carry:** **0** = Escribir; **1** = Leer.<br/>**X:** Columna (Carry = 0).<br/>**Y:** Fila (Carry = 0). | **X:** Columna (Carry = 1).<br/>**Y:** Fila (Carry = 1). | X, Y | Lee o escribe la posición del cursor. |
| `IOBASE` | \$FFF3 (\$E500) | - | **X/Y:** Dirección base CIA1 (\$DC00). | X, Y | Obtener la dirección base de la CIA1. |

Algunas de las rutinas del KERNAL son para trabajar con ficheros. Primero hay que configurar los parámetros del fichero con `SETLFS` y `SETNAM`. A continuación se sigue el siguiente esquema:

1. Abrir el fichero con `OPEN`.
2. Usar el fichero como E/S por defecto con `CHKIN`/`CHKOUT`.
3. Operaciones de lectura y escritura con `GETIN`, `CHRIN` o `CHROUT`.
4. Restaurar la E/S por defecto con `CLRCHN`
5. Cerrar el fichero con `CLOSE`.

Con la rutina `READST` se podrá obtener en el registro A el estado del dispositivo del fichero con el que se está trabajando, para comprobar si ha habido errores o si se ha llegado al final de fichero, entre otras cosas.

### Rutinas de la pantalla

Además de las rutinas `SCREEN` y `PLOT`, existen también:

| Dirección | Entradas | Salidas | Usados | Descripción |
|:---------:|----------|---------|:------:|-------------|
| \$E4DA | **Y:** Columna. | - | A | Poner el color del cursor (\$0286) en la posición apuntada por \$00F3-\$00F4 del buffer de color. |
| \$E518 | - | - | A, X, Y | Inicializar VIC, asignar E/S por defecto (teclado/pantalla) y borrar pantalla. |
| \$E544 | - | - | A, X, Y | Borrar pantalla. |
| \$E566 | - | - | A, X, Y | Mueve el cursor al inicio de la pantalla (esquina superior izquierda). |
| \$E56C | - | - | A, X, Y | Actualiza, a la línea actual, el puntero en \$00D1-\$00D2 al buffer de pantalla y el puntero en \$00F3-\$00F4 al buffer de color, en base a la fila (\$00D6) y columna (\$00D3) del cursor. |
| \$E59A | - | - | A, X, Y | Inicializar VIC, asignar E/S por defecto (teclado/pantalla) y mover el cursor al inicio de la pantalla. |
| \$E5A0 | - | - | A, X | Inicializar VIC y asignar E/S por defecto (teclado/pantalla). |
| \$E5A8 | - | - | A, X | Inicializar VIC. |
| \$E632 | - | **A:** Byte leído. | A | Lee un byte de la pantalla. Si la línea de entrada está vacía, aparece el cursor y se introduce una línea de datos. |
| \$E684 | - | - | - | Comprueba un código PETSCII. Si es \$22 (`"`), se invierte el modo comillas en \$00D4. |
| \$E6B6 | - | - | A, X, Y | Recalcula los bytes altos de los punteros (\$00D9-\$00F1) a las líneas en el buffer de pantalla. |
| \$E716 | **A:** Byte para escribir. | - | - | Escribe un byte en pantalla. |
| \$E8CB | - | - | A, X | Comprueba un código PETSCII. Si pertenece a un color, modifica el color del cursor (\$0286). |
| \$E8EA | - | - | A, X, Y | Desplaza toda la pantalla hacia arriba. |
| \$E965 | - | - | A, X, Y | Inserta una línea antes de la actual y desplaza las siguientes líneas de pantalla hacia abajo. |
| \$E9F0 | **X:** Fila. | - | A | Modifica el puntero en \$00D1-\$00D2 a la línea actual en el buffer de pantalla, consultando el byte alto de la tabla de punteros en \$00D9-\$00F1. |
| \$E9FF | **X:** Fila. | - | A, Y | Borra una línea de pantalla. |
| \$EA13 | **A:** Carácter<br/>**X:** Color. | - | A, Y | Escribe un carácter y color en pantalla, modificando el tiempo de parpadeo del cursor a 2. |
| \$EA24 | - | - | - | Modifica el puntero en \$00F3-\$00F4 a la línea actual en el buffer de color, consultando el puntero \$00D1-\$00D2 a la línea actual en el buffer de pantalla. |

### Rutinas del teclado

Además de las rutinas `SCNKEY` y `STOP`, existen también:

| Dirección | Entradas | Salidas | Usados | Descripción |
|:---------:|----------|---------|:------:|-------------|
| \$E5B4 | - | **A:** Byte leído. | A, X, Y | Lee un byte del buffer de teclado, el buffer de las teclas `SHIFT` y decrementa los punteros al buffer. |
| \$F142 | - | **A:** Byte leído (0 = Ninguna tecla pulsada). | A, X, Y | Lee un byte del buffer de teclado, el buffer de las teclas `SHIFT` y decrementa los punteros al buffer. |
| \$F6BC | - | - | A, X | Actualiza el estado de la tecla `RUN/STOP` (\$0091). |

### Rutinas del puerto serie

Además de las rutinas `LSTNSA`, `TALKSA`, `SETTMO`, `IECIN`, `IECOUT`, `UNTALK`, `UNLSTN`, `LISTEN` y `TALK`, existen también:

| Dirección | Entradas | Salidas | Usados | Descripción |
|:---------:|----------|---------|:------:|-------------|
| \$ED40 | - | - | A | *Flush* de la caché de salida (\$0095) del puerto serie hacia el puerto serie. |
| \$EE85 | - | - | A | Modifica el *CLOCK OUT* a *high*. |
| \$EE8E | - | - | A | Modifica el *CLOCK OUT* a *low*. |
| \$EE97 | - | - | A | Modifica el *DATA OUT* a *high*. |
| \$EEA0 | - | - | A | Modifica el *DATA OUT* a *low*. |
| \$EEA9 | - | **Carry:** *DATA IN*<br/>**Negative:** *CLOCK IN*<br/>**A:** *CLOCK IN* (Bit 7). | A | Lee el CLOCK IN y el DATA IN. |
| \$F1AD | - | **A:** Byte leído | A | Lee un byte del puerto serie. Lee \$0D (`RETURN`), si `STATUS <> 0`. |
| \$F237 | **A:** Número de dispositivo. | - | A, X | Define el puerto serie como entrada por defecto. No se envíe *TALK* a la dirección secundaria si el bit 7 del modo de apertura vale 1. |
| \$F279 | **A:** Número de dispositivo. | - | A, X | Define el puerto serie como salida por defecto. No se envíe *LISTEN* a la dirección secundaria si el bit 7 del modo de apertura vale `1`. |
| \$F3D5 | - | - | A, Y | Abre un fichero en el puerto serie. No se envíe el nombre de fichero si el bit 7 del modo de apertura vale `1` o si el tamaño del nombre de fichero es `0`. |
| \$F528 | - | - | A | Enviar el comando *UNTALK* y *CLOSE* al puerto serie. |
| \$F63F | - | - | A | Enviar el comando *UNLISTEN* y *CLOSE* al puerto serie. |
| \$F642 | - | - | - | Cierra un fichero en el puerto serie. No se envíe *CLOSE* a la dirección secundaria si el bit 7 del modo de apertura vale `1`. |

### Rutinas del *datasette*

Estas son las rutinas que existen para manejar el *datasette*:

| Dirección | Entradas | Salidas | Usados | Descripción |
|:---------:|----------|---------|:------:|-------------|
| \$F179 | - | **A:** Byte leído. | A, Y | Leer un byte del *datasette* (sólo ficheros de datos). |
| \$F1DD | **Carry = 1:** Escribir byte; **A:** Byte para escribir; **Carry = 0:** Escribir EOF. | - | - | Escribir un byte en el *datasette*. |
| \$F22A | **A = 1** | - | A, X | Define el *datasette* como entrada por defecto. |
| \$F26F | **A = 1** | - | A, X | Define el *datasette* como salida por defecto. |
| \$F2C8 | - | - | A, X, Y | Cerrar un fichero en el *datasette* (sólo ficheros de datos). Primero escribe \$00 y fin de fichero (EOF). (Previamente se debe meter en la pila el número identificador de fichero.) |
| \$F38B | - | - | A, X, Y | Abrir un fichero en el *datasette* (sólo ficheros de datos). Se lanza un `ILLEGAL DEVICE NUMBER` si el puntero al buffer del *datasette* (\$00B2-\$00B3) está por debajo de \$0200. |
| \$F72C | - | **X:** Tipo de cabecera; **Carry = 1 y Zero = 1:** Interrumpido por pulsarse *STOP*; **Carry = 1 y Zero = 0:** Interrumpido por alcanzarse el final de cinta (EOT). | A, X, Y | Leer la cabecera en el *datasette*. |
| \$F76A | **A:** Tipo de cabecera. | **Carry = 1 y Zero = 1:** Interrumpido por pulsarse *STOP*. | A, X, Y | Generar y escribir la cabecera en el *datasette*. |
| \$F7D0 | - | **Carry = 0:** Puntero por debajo de \$0200; **X/Y:** Puntero. | X, Y | Obtener el puntero al buffer del *datasette*. |
| \$F7EA | - | **X:** Tipo de cabecera; **Carry = 1 y Zero = 1:** Interrumpido por pulsarse *STOP*; **Carry = 1 y Zero = 0:** Interrumpido por alcanzarse el final de cinta (EOT). | A, X, Y | Buscar un fichero en el *datasette*. (Debe llamarse `SETLFS` y `SETNAM` previamente.) |
| \$F80D | - | **Zero = 1:** Buffer lleno; **Carry = 1 y Zero = 0:** Desbordamiento del buffer. | X, Y | Incrementar el puntero al buffer del *datasette*. |
| \$F817 | - | **Carry = 1:** Interrumpido por pulsarse *STOP*. | A, Y | Esperar a que se pulse *PLAY* en el *datasette*. |
| \$F82E | - | **Zero:** **0** = Nada pulsado; **1** = *PLAY*, *RECORD*, *F.FWD* y/o *REW* pulsados. | - | Detecta si se ha pulsado algún botón en el *datasette*. |
| \$F838 | - | **Carry = 1:** Interrumpido por pulsarse *STOP*. | A, Y | Esperar a que se pulse *RECORD* en el *datasette*. |
| \$F841 | - | **Carry = 1 y Zero = 1:** Interrumpido por pulsarse *STOP*. | A, X, Y | Lee un bloque del *datasette*. |
| \$F84A | - | **Carry = 1 y Zero = 1:** Interrumpido por pulsarse *STOP*. | A, X, Y | Lee un fichero de programa del *datasette*. |
| \$F864 | - | **Carry = 1 y Zero = 1:** Interrumpido por pulsarse *STOP*. | A, X, Y | Escribe un bloque en el *datasette*. |
| \$F86B | - | **Carry = 1 y Zero = 1:** Interrumpido por pulsarse *STOP*. | A, X, Y | Escribe un fichero de programa en el *datasette*. |
| \$FC93 | - | - | A | Apaga el motor del *datasette*; cambia la pantalla hacia atrás; restaura la dirección de ejecución de la rutina de servicio de interrupciones desde \$029F-\$02A0. |
| \$FCCA | - | - | A | Apaga el motor del *datasette*. |

### Rutinas del RS-232

Estas son las rutinas que existen para manejar el RS-232:

| Dirección | Entradas | Salidas | Usados | Descripción |
|:---------:|----------|---------|:------:|-------------|
| \$EF4A | - | **X:** Número de bits de datos. | A, X | Calcular el número de bits de datos, de acuerdo a \$0293. |
| \$EFE1 | **A = 2** | - | A | Definir el RS-232 como salida por defecto. |
| \$F017 | - | - | A, Y | Escribir un byte en el RS-232, desde la caché de salida del RS-232. |
| \$F04D | **A = 2** | - | A | Definir el RS-232 como entrada por defecto. |
| \$F086 | - | **A:** Byte leído. | - | Leer un byte del RS-232. |
| \$F0A4 | - | - | - | Esperar al final de la transferencia y desactivar las interrupciones del RS-232. (Para que registros de chips comunes puedan utilizarse por el puerto serie o la E/S del *datasette*.) |
| \$F14E | - | **A:** Byte leído. | A | Leer un byte del RS-232. |
| \$F1B8 | - | **A:** Byte leído. | A | Leer un byte del RS-232; reintentar ante un byte \$00. |
| \$F1DD | **Carry = 0**; **A:** Byte para escribir. | - | - | Escribir un byte en el RS-232. |
| \$F2AF | - | - | A, X, Y | Cerrar un fichero en el RS-232; liberar, si existe, los buffers de E/S del RS-232. |
| \$F409 | - | - | A, X, Y | Abrir un fichero en el RS-232; ubicar, si no existen, los buffers de E/S del RS-232. |
| \$F483 | - | - | A, Y | Inicializar la CIA2 para abrir/cerrar el RS-232. |

### Rutinas BASIC de conversión

El interprete de BASIC tiene implementada su propia representación de [números de coma flotante](https://www.c64-wiki.com/wiki/Floating_point_arithmetic) y tiene algunas rutinas para trabajar con ellos:

| Dirección | Descripción |
|:---------:|-------------|
| \$A96B | Lee el número de línea del programa BASIC y lo escribe en \$0014-\$0015. Si el primer carácter no es un dígito, el resultado será `0`. Si el resultado es igual o superior a `64000`, se lanzará un `SYNTAX ERROR`. (NOTA: Necesita que `CHRGET` haya sido invocado previamente para consultar \$0073.) |
| \$A9C4 | Convierte el FAC a entero y lo escribe en la variable apuntada por \$0049-\$004A. |
| \$A9DA | Asigna un valor a una variable de cadena, incluida `TI$`. (NOTA: Consultar también la rutina \$AA2C.) |
| \$A9E0 | Asigna un valor a `TI$` y cambia el TOD. Lee el valor de la cadena apuntada por \$0064-\$0065. |
| \$AA2C | Asigna un valor a una variable de cadena, excluyendo `TI$`. Lee el valor de la cadena apuntada por \$0064-\$0065 y escribe el valor en la cadena apuntada por \$0049-\$004A. |
| \$AD8A | Lee el valor de una expresión numérica del programa BASIC y lo escribe en el FAC. |
| \$AD8D | Comprueba si una expresión es numérica, si no lo es lanza un `TYPE MISMATCH`. |
| \$AD8F | Comprueba si una expresión es una cadena, si no lo es lanza un `TYPE MISMATCH`. |
| \$AD9E | Lee el valor de una expresión del programa BASIC. Para expresiones numéricas se escribe el valor en el FAC; para expresiones de cadena, el tamaño se escribe en \$0061 y la dirección del valor en \$0062-\$0063. |
| \$AEF1 | Lee el valor de una expresión entre paréntesis del programa BASIC. (NOTA: Consultar también la rutina \$AD9E.) |
| \$AF28 | Lee el nombre de una variable del programa BASIC y carga su valor. La dirección de la variable se escribe en \$0064-\$0065; para variables numéricas, se escribe su valor en el FAC, en formato de coma flotante; para `ST`, `TI` y `TI$`, toma el valor de sus direcciones de memoria del sistema; para variables que no existen devuelve el valor vacío (`0` para números y `""` para cadenas). |
| \$AF48 | Calcular el valor de `TI$`. |
| \$AF61 | Escribe en el FAC, en formato de coma flotante, el valor de la variable entera apuntada por \$0064-\$0065. |
| \$AF6E | Escribe en el FAC el valor de una variable flotante, incluidas `ST` y `TI`. (NOTA: Consultar también la rutina \$AFA0.) |
| \$AF7B | Calcular el valor de `TI` en el FAC. |
| \$AF9A | Calcular el valor de `ST` en el FAC. |
| \$AFA0 | Escribe en el FAC el valor de la variable flotante apuntada por \$0064-\$0065, excluyendo `ST` y `TI`. |
| \$B08B | Lee el nombre de una variable del programa BASIC y la busca. Si la encuentra, la dirección de la variable es escrita en \$005F-\$0060, la dirección del valor es escrita en \$0047-\$0048; si no la encuentra, y el invocador es \$AF28, devuelve el valor vacío (`0` para números y `""` para cadenas), sino crea una nueva variable con el valor vacío. |
| \$B128 | Crea una nueva variable con el valor vacío (`0` para números y `""` para cadenas). El nombre de la variable está en \$0045-\$0046. |
| \$B1B2 | Lee un valor entero del programa BASIC y lo escribe en \$0064-\$0065. Si el valor no está dentro del rango [-32768, 32767], se lanza un `ILLEGAL QUANTITY`. |
| \$B391 | Escribe el entero en A/Y en el FAC en formato de coma flotante. |
| \$B3A2 | Escribe el entero en Y en el FAC en formato de coma flotante. |
| \$B794 | Escribe el entero en A en el FAC en formato de coma flotante. |
| \$B79B | Lee un BYTE del programa BASIC y lo escribe en X. Si el valor no está dentro del rango [0, 255], se lanza un `ILLEGAL QUANTITY`. |
| \$B7EB | Lee un WORD y un BYTE, separados por una coma, del programa BASIC y lo escribe en \$0014-\$0015 y X. |
| \$B7F7 | Convierte el FAC en un valor entero sin signo y lo escribe en \$0014-\$0015. Si el valor no está dentro del rango [0, 65535], se lanza un `ILLEGAL QUANTITY`. |
| \$B849 | `FAC = FAC + 0.5` |
| \$B850 | `FAC = (valor flotante apuntado por A/Y) – FAC` |
| \$B853 | `FAC = ARG – FAC` |
| \$B867 | `FAC = (valor flotante apuntado por A/Y) + FAC` |
| \$B86A | `FAC = ARG + FAC` (Requiere un `LDA $61` previo.) |
| \$B947 | `FAC = ComplementoA2(FAC)`, invierte la mantisa del FAC. |
| \$BA28 | `FAC := (valor flotante apuntado por A/Y) * FAC` |
| \$BA2B | `FAC = ARG * FAC` (Requiere un `LDA $61` previo.) |
| \$BA8C | `ARG = (valor flotante apuntado por A/Y)` |
| \$BAE2 | `FAC = FAC * 10` |
| \$BAFE | `FAC = FAC / 10` |
| \$BB0F | `FAC = (valor flotante apuntado por A/Y) / FAC` |
| \$BB12 | `FAC = ARG / FAC`; si el FAC es `0`, lanzar un `DIVISION BY ZERO`. (Requiere un `LDA $61` previo.) |
| \$BBA2 | `FAC = (valor flotante apuntado por A/Y)` |
| \$BBC7 | `Registro Aritmético 4 = FAC` |
| \$BBCA | `Registro Aritmético 3 = FAC` |
| \$BBD0 | Escribe el FAC en la variable flotante apuntada por \$0049-\$004A. |
| \$BBD4 | Escribe el FAC en la variable flotante apuntada por X/Y. |
| \$BBFC | `FAC = ARG` |
| \$BC0C | `ARG = Entero(FAC)` |
| \$BC0F | `ARG = FAC` |
| \$BC1B | `FAC = Entero(FAC)` |
| \$BC2B | Escribe signo del FAC en A: 1 = Positivo; 0 = Cero; 255 = Negativo. |
| \$BC5B | Compara el valor flotante apuntado por A/Y con el FAC y lo escribe en A: 1 = FAC menor; 0 = Igual; 255 = FAC mayor. |
| \$BC9B | Convierte el FAC a entero y lo escribe en \$0064-\$0065. |
| \$BCF3 | Lee un valor flotante del programa BASIC y lo escribe en el FAC. |
| \$BDCD | Escribe en pantalla el entero en A/X en formato de coma flotante. |
| \$BDDD | Convierte el FAC a una cadena terminada en `0` almacenada en \$0100-\$010A. |
| \$BF71 | `FAC = RaízCuadrada(FAC)` |
| \$BF78 | `FAC = ARG ^ (valor flotante apuntado por A/Y)` |
| \$BF7B | `FAC = ARG ^ FAC` |
| \$BFB4 | `FAC := –FAC` |

